{"version":3,"names":["Style","StatusBar","getEngine","_a","win","Capacitor","isPluginAvailable","Plugins","supportsDefaultStatusBarStyle","PluginHeaders","setStyle","options","engine","this","getStyle","Default","getInfo","style","_b","sent","getBackdropValueForSheet","x","backdropBreakpoint","slope","b","setCardStatusBarDark","innerWidth","Dark","setCardStatusBarDefault","defaultStyle","handleCanDismiss","el","animation","__awaiter","canDismiss","undefined","GESTURE","shouldDismiss","isRunning","onFinish","dismiss","oneTimeCallback","calculateSpringStep","t","Math","pow","SwipeToCloseDefaults","MIN_PRESENTING_SCALE","createSwipeToCloseGesture","statusBarStyle","onDismiss","DISMISS_THRESHOLD","height","offsetHeight","isOpen","canDismissBlocksGesture","contentEl","scrollEl","canDismissMaxStep","initialScrollY","lastStep","getScrollY","isIonContent","scrollY","canStart","detail","target","event","closest","findClosestIonContent","root","getElementRoot","querySelector","hasRefresherInContent","scrollTop","footer","onStart","deltaY","disableContentScrollY","progressStart","onMove","step","isAttemptingDismissWithCanDismiss","maxStep","processedStep","clampedStep","clamp","progressStep","onEnd","velocity","velocityY","threshold","shouldComplete","newStepValue","easing","getTimeGivenProgression","duration","computeDuration","gesture","enable","resetContentScrollY","progressEnd","createGesture","gestureName","gesturePriority","direction","remaining","abs","createSheetEnterAnimation","opts","currentBreakpoint","shouldShowBackdrop","initialBackdrop","concat","backdropAnimation","createAnimation","fromTo","beforeStyles","afterClearStyles","wrapperAnimation","keyframes","offset","opacity","transform","createSheetLeaveAnimation","backdropValue","defaultBackdrop","customBackdrop","createEnterAnimation","iosEnterAnimation","baseEl","presentingEl","addElement","querySelectorAll","baseAnimation","addAnimation","isMobile","window","hasCardModal","tagName","presentingElement","presentingElRoot","presentingAnimation","overflow","bodyEl_1","document","body","transformOffset","CSS","supports","modalTransform","toPresentingScale","finalTransform","afterStyles","beforeAddWrite","setProperty","filter","borderRadius","shadowAnimation","createLeaveAnimation","iosLeaveAnimation","beforeClearStyles","currentStep","numModals","Array","from","bodyEl_2","m","length","mdEnterAnimation","mdLeaveAnimation","createSheetGesture","backdropEl","wrapperEl","initialBreakpoint","breakpoints","getCurrentBreakpoint","onBreakpointChange","SheetDefaults","WRAPPER_KEYFRAMES","BACKDROP_KEYFRAMES","clientHeight","childAnimations","find","ani","id","maxBreakpoint","minBreakpoint","enableBackdrop","classList","remove","disableBackdrop","add","__spreadArray","shouldEnableBackdrop","content","raf","focus","initialStep","secondToLastBreakpoint","diff","reduce","a","moveSheetToBreakpoint","breakpoint","breakpointOffset","shouldPreventDismiss","snapToBreakpoint","shouldRemainOpen","Promise","resolve","modalIosCss","modalMdCss","Modal","class_1","hostRef","_this","modalIndex","modalIds","coreDelegate","CoreDelegate","isSheetModal","inheritedAttributes","inline","gestureAnimationDismissing","presented","hasController","keyboardClose","handleBehavior","backdropDismiss","showBackdrop","animated","swipeToClose","keepContentsMounted","configureTriggerInteraction","trigger","destroyTriggerInteraction","triggerEl","getElementById","printIonWarning","trigEl","modalEl","openModal","present","addEventListener","removeEventListener","onHandleClick","sheetTransition","moveToNextBreakpoint","onBackdropTap","BACKDROP","onLifecycle","modalEvent","usersElement","name","LIFECYCLE_MAP","type","ev","CustomEvent","bubbles","cancelable","dispatchEvent","prototype","onIsOpenChange","newValue","oldValue","onTriggerChange","swipeToCloseChanged","initSwipeToClose","breakpointsChanged","sortedBreakpoints","sort","connectedCallback","prepareOverlay","disconnectedCallback","componentWillLoad","inheritAttributes","modalId","hasAttribute","getAttribute","includes","componentDidLoad","getDelegate","force","workingDelegate","delegate","parentEl","parentNode","checkCanDismiss","data","role","currentTransition","_e","_c","attachComponent","component","componentProps","deepReady","writeTask","getIonMode","_d","initSheetGesture","keyboardOpenCallback","KEYBOARD_DID_OPEN","animationBuilder","leaveAnimation","config","get","findIonContent","printIonContentErrorMsg","StatusBarStyle","enterAnimation","sheetOnDismiss","ionBreakpointDidChange","emit","enteringAnimation","activeAnimations","dismissed","detachComponent","destroy","forEach","onDidDismiss","eventMethod","onWillDismiss","setCurrentBreakpoint","allowedBreakpoints","currentBreakpointIndex","indexOf","nextBreakpointIndex","nextBreakpoint","render","handle","htmlAttributes","showHandle","mode","isCardModal","isHandleCycle","h","Host","Object","assign","tabindex","zIndex","overlayIndex","class","getClassMap","cssClass","onIonBackdropTap","onIonModalDidPresent","onIonModalWillPresent","onIonModalWillDismiss","onIonModalDidDismiss","ref","visible","tappable","part","tabIndex","onClick","ionModalDidPresent","ionModalWillPresent","ionModalWillDismiss","ionModalDidDismiss"],"sources":["node_modules/@ionic/core/dist/collection/utils/native/status-bar.js","node_modules/@ionic/core/dist/collection/components/modal/utils.js","node_modules/@ionic/core/dist/collection/components/modal/gestures/utils.js","node_modules/@ionic/core/dist/collection/components/modal/gestures/swipe-to-close.js","node_modules/@ionic/core/dist/collection/components/modal/animations/sheet.js","node_modules/@ionic/core/dist/collection/components/modal/animations/ios.enter.js","node_modules/@ionic/core/dist/collection/components/modal/animations/ios.leave.js","node_modules/@ionic/core/dist/collection/components/modal/animations/md.enter.js","node_modules/@ionic/core/dist/collection/components/modal/animations/md.leave.js","node_modules/@ionic/core/dist/collection/components/modal/gestures/sheet.js","node_modules/@ionic/core/dist/collection/components/modal/modal.ios.css?tag=ion-modal&mode=ios&encapsulation=shadow","node_modules/@ionic/core/dist/collection/components/modal/modal.md.css?tag=ion-modal&mode=md&encapsulation=shadow","node_modules/@ionic/core/dist/collection/components/modal/modal.js"],"sourcesContent":["/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { win } from '../window';\nexport var Style;\n(function (Style) {\n  Style[\"Dark\"] = \"DARK\";\n  Style[\"Light\"] = \"LIGHT\";\n  Style[\"Default\"] = \"DEFAULT\";\n})(Style || (Style = {}));\nexport const StatusBar = {\n  getEngine() {\n    var _a;\n    return ((_a = win === null || win === void 0 ? void 0 : win.Capacitor) === null || _a === void 0 ? void 0 : _a.isPluginAvailable('StatusBar')) && (win === null || win === void 0 ? void 0 : win.Capacitor.Plugins.StatusBar);\n  },\n  supportsDefaultStatusBarStyle() {\n    var _a;\n    /**\n     * The 'DEFAULT' status bar style was added\n     * to the @capacitor/status-bar plugin in Capacitor 3.\n     * PluginHeaders is only supported in Capacitor 3+,\n     * so we can use this to detect Capacitor 3.\n     */\n    return !!((_a = win === null || win === void 0 ? void 0 : win.Capacitor) === null || _a === void 0 ? void 0 : _a.PluginHeaders);\n  },\n  setStyle(options) {\n    const engine = this.getEngine();\n    if (!engine) {\n      return;\n    }\n    engine.setStyle(options);\n  },\n  getStyle: async function () {\n    const engine = this.getEngine();\n    if (!engine) {\n      return Style.Default;\n    }\n    const { style } = await engine.getInfo();\n    return style;\n  },\n};\n","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { StatusBar, Style } from '../../utils/native/status-bar';\nimport { win } from '../../utils/window';\n/**\n * Use y = mx + b to\n * figure out the backdrop value\n * at a particular x coordinate. This\n * is useful when the backdrop does\n * not begin to fade in until after\n * the 0 breakpoint.\n */\nexport const getBackdropValueForSheet = (x, backdropBreakpoint) => {\n  /**\n   * We will use these points:\n   * (backdropBreakpoint, 0)\n   * (maxBreakpoint, 1)\n   * We know that at the beginning breakpoint,\n   * the backdrop will be hidden. We also\n   * know that at the maxBreakpoint, the backdrop\n   * must be fully visible. maxBreakpoint should\n   * always be 1 even if the maximum value\n   * of the breakpoints array is not 1 since\n   * the animation runs from a progress of 0\n   * to a progress of 1.\n   * m = (y2 - y1) / (x2 - x1)\n   *\n   * This is simplified from:\n   * m = (1 - 0) / (maxBreakpoint - backdropBreakpoint)\n   *\n   * If the backdropBreakpoint is 1, we return 0 as the\n   * backdrop is completely hidden.\n   *\n   */\n  if (backdropBreakpoint === 1) {\n    return 0;\n  }\n  const slope = 1 / (1 - backdropBreakpoint);\n  /**\n   * From here, compute b which is\n   * the backdrop opacity if the offset\n   * is 0. If the backdrop does not\n   * begin to fade in until after the\n   * 0 breakpoint, this b value will be\n   * negative. This is fine as we never pass\n   * b directly into the animation keyframes.\n   * b = y - mx\n   * Use a known point: (backdropBreakpoint, 0)\n   * This is simplified from:\n   * b = 0 - (backdropBreakpoint * slope)\n   */\n  const b = -(backdropBreakpoint * slope);\n  /**\n   * Finally, we can now determine the\n   * backdrop offset given an arbitrary\n   * gesture offset.\n   */\n  return x * slope + b;\n};\n/**\n * The tablet/desktop card modal activates\n * when the window width is >= 768.\n * At that point, the presenting element\n * is not transformed, so we do not need to\n * adjust the status bar color.\n *\n * Note: We check supportsDefaultStatusBarStyle so that\n * Capacitor <= 2 users do not get their status bar\n * stuck in an inconsistent state due to a lack of\n * support for Style.Default.\n */\nexport const setCardStatusBarDark = () => {\n  if (!win || win.innerWidth >= 768 || !StatusBar.supportsDefaultStatusBarStyle()) {\n    return;\n  }\n  StatusBar.setStyle({ style: Style.Dark });\n};\nexport const setCardStatusBarDefault = (defaultStyle = Style.Default) => {\n  if (!win || win.innerWidth >= 768 || !StatusBar.supportsDefaultStatusBarStyle()) {\n    return;\n  }\n  StatusBar.setStyle({ style: defaultStyle });\n};\n","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { GESTURE } from '../../../utils/overlays';\nexport const handleCanDismiss = async (el, animation) => {\n  /**\n   * If canDismiss is not a function\n   * then we can return early. If canDismiss is `true`,\n   * then canDismissBlocksGesture is `false` as canDismiss\n   * will never interrupt the gesture. As a result,\n   * this code block is never reached. If canDismiss is `false`,\n   * then we never dismiss.\n   */\n  if (typeof el.canDismiss !== 'function') {\n    return;\n  }\n  /**\n   * Run the canDismiss callback.\n   * If the function returns `true`,\n   * then we can proceed with dismiss.\n   */\n  const shouldDismiss = await el.canDismiss(undefined, GESTURE);\n  if (!shouldDismiss) {\n    return;\n  }\n  /**\n   * If canDismiss resolved after the snap\n   * back animation finished, we can\n   * dismiss immediately.\n   *\n   * If canDismiss resolved before the snap\n   * back animation finished, we need to\n   * wait until the snap back animation is\n   * done before dismissing.\n   */\n  if (animation.isRunning()) {\n    animation.onFinish(() => {\n      el.dismiss(undefined, 'handler');\n    }, { oneTimeCallback: true });\n  }\n  else {\n    el.dismiss(undefined, 'handler');\n  }\n};\n/**\n * This function lets us simulate a realistic spring-like animation\n * when swiping down on the modal.\n * There are two forces that we need to use to compute the spring physics:\n *\n * 1. Stiffness, k: This is a measure of resistance applied a spring.\n * 2. Dampening, c: This value has the effect of reducing or preventing oscillation.\n *\n * Using these two values, we can calculate the Spring Force and the Dampening Force\n * to compute the total force applied to a spring.\n *\n * Spring Force: This force pulls a spring back into its equilibrium position.\n * Hooke's Law tells us that that spring force (FS) = kX.\n * k is the stiffness of a spring, and X is the displacement of the spring from its\n * equilibrium position. In this case, it is the amount by which the free end\n * of a spring was displaced (stretched/pushed) from its \"relaxed\" position.\n *\n * Dampening Force: This force slows down motion. Without it, a spring would oscillate forever.\n * The dampening force, FD, can be found via this formula: FD = -cv\n * where c the dampening value and v is velocity.\n *\n * Therefore, the resulting force that is exerted on the block is:\n * F = FS + FD = -kX - cv\n *\n * Newton's 2nd Law tells us that F = ma:\n * ma = -kX - cv.\n *\n * For Ionic's purposes, we can assume that m = 1:\n * a = -kX - cv\n *\n * Imagine a block attached to the end of a spring. At equilibrium\n * the block is at position x = 1.\n * Pressing on the block moves it to position x = 0;\n * So, to calculate the displacement, we need to take the\n * current position and subtract the previous position from it.\n * X = x - x0 = 0 - 1 = -1.\n *\n * For Ionic's purposes, we are only pushing on the spring modal\n * so we have a max position of 1.\n * As a result, we can expand displacement to this formula:\n * X = x - 1\n *\n * a = -k(x - 1) - cv\n *\n * We can represent the motion of something as a function of time: f(t) = x.\n * The derivative of position gives us the velocity: f'(t)\n * The derivative of the velocity gives us the acceleration: f''(t)\n *\n * We can substitute the formula above with these values:\n *\n * f\"(t) = -k * (f(t) - 1) - c * f'(t)\n *\n * This is called a differential equation.\n *\n * We know that at t = 0, we are at x = 0 because the modal does not move: f(0) = 0\n * This means our velocity is also zero: f'(0) = 0.\n *\n * We can cheat a bit and plug the formula into Wolfram Alpha.\n * However, we need to pick stiffness and dampening values:\n * k = 0.57\n * c = 15\n *\n * I picked these as they are fairly close to native iOS's spring effect\n * with the modal.\n *\n * What we plug in is this: f(0) = 0; f'(0) = 0; f''(t) = -0.57(f(t) - 1) - 15f'(t)\n *\n * The result is a formula that lets us calculate the acceleration\n * for a given time t.\n * Note: This is the approximate form of the solution. Wolfram Alpha will\n * give you a complex differential equation too.\n */\nexport const calculateSpringStep = (t) => {\n  return 0.00255275 * 2.71828 ** (-14.9619 * t) - 1.00255 * 2.71828 ** (-0.0380968 * t) + 1;\n};\n","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { getTimeGivenProgression } from '../../../utils/animation/cubic-bezier';\nimport { isIonContent, findClosestIonContent, disableContentScrollY, resetContentScrollY, } from '../../../utils/content';\nimport { createGesture } from '../../../utils/gesture';\nimport { clamp, getElementRoot } from '../../../utils/helpers';\nimport { setCardStatusBarDark, setCardStatusBarDefault } from '../utils';\nimport { calculateSpringStep, handleCanDismiss } from './utils';\n// Defaults for the card swipe animation\nexport const SwipeToCloseDefaults = {\n  MIN_PRESENTING_SCALE: 0.93,\n};\nexport const createSwipeToCloseGesture = (el, animation, statusBarStyle, onDismiss) => {\n  /**\n   * The step value at which a card modal\n   * is eligible for dismissing via gesture.\n   */\n  const DISMISS_THRESHOLD = 0.5;\n  const height = el.offsetHeight;\n  let isOpen = false;\n  let canDismissBlocksGesture = false;\n  let contentEl = null;\n  let scrollEl = null;\n  const canDismissMaxStep = 0.2;\n  let initialScrollY = true;\n  let lastStep = 0;\n  const getScrollY = () => {\n    if (contentEl && isIonContent(contentEl)) {\n      return contentEl.scrollY;\n      /**\n       * Custom scroll containers are intended to be\n       * used with virtual scrolling, so we assume\n       * there is scrolling in this case.\n       */\n    }\n    else {\n      return true;\n    }\n  };\n  const canStart = (detail) => {\n    const target = detail.event.target;\n    if (target === null || !target.closest) {\n      return true;\n    }\n    /**\n     * If we are swiping on the content,\n     * swiping should only be possible if\n     * the content is scrolled all the way\n     * to the top so that we do not interfere\n     * with scrolling.\n     *\n     * We cannot assume that the `ion-content`\n     * target will remain consistent between\n     * swipes. For example, when using\n     * ion-nav within a card modal it is\n     * possible to swipe, push a view, and then\n     * swipe again. The target content will not\n     * be the same between swipes.\n     */\n    contentEl = findClosestIonContent(target);\n    if (contentEl) {\n      /**\n       * The card should never swipe to close\n       * on the content with a refresher.\n       * Note: We cannot solve this by making the\n       * swipeToClose gesture have a higher priority\n       * than the refresher gesture as the iOS native\n       * refresh gesture uses a scroll listener in\n       * addition to a gesture.\n       *\n       * Note: Do not use getScrollElement here\n       * because we need this to be a synchronous\n       * operation, and getScrollElement is\n       * asynchronous.\n       */\n      if (isIonContent(contentEl)) {\n        const root = getElementRoot(contentEl);\n        scrollEl = root.querySelector('.inner-scroll');\n      }\n      else {\n        scrollEl = contentEl;\n      }\n      const hasRefresherInContent = !!contentEl.querySelector('ion-refresher');\n      return !hasRefresherInContent && scrollEl.scrollTop === 0;\n    }\n    /**\n     * Card should be swipeable on all\n     * parts of the modal except for the footer.\n     */\n    const footer = target.closest('ion-footer');\n    if (footer === null) {\n      return true;\n    }\n    return false;\n  };\n  const onStart = (detail) => {\n    const { deltaY } = detail;\n    /**\n     * Get the initial scrollY value so\n     * that we can correctly reset the scrollY\n     * prop when the gesture ends.\n     */\n    initialScrollY = getScrollY();\n    /**\n     * If canDismiss is anything other than `true`\n     * then users should be able to swipe down\n     * until a threshold is hit. At that point,\n     * the card modal should not proceed any further.\n     * TODO (FW-937)\n     * Remove undefined check\n     */\n    canDismissBlocksGesture = el.canDismiss !== undefined && el.canDismiss !== true;\n    /**\n     * If we are pulling down, then\n     * it is possible we are pulling on the\n     * content. We do not want scrolling to\n     * happen at the same time as the gesture.\n     */\n    if (deltaY > 0 && contentEl) {\n      disableContentScrollY(contentEl);\n    }\n    animation.progressStart(true, isOpen ? 1 : 0);\n  };\n  const onMove = (detail) => {\n    const { deltaY } = detail;\n    /**\n     * If we are pulling down, then\n     * it is possible we are pulling on the\n     * content. We do not want scrolling to\n     * happen at the same time as the gesture.\n     */\n    if (deltaY > 0 && contentEl) {\n      disableContentScrollY(contentEl);\n    }\n    /**\n     * If we are swiping on the content\n     * then the swipe gesture should only\n     * happen if we are pulling down.\n     *\n     * However, if we pull up and\n     * then down such that the scroll position\n     * returns to 0, we should be able to swipe\n     * the card.\n     */\n    const step = detail.deltaY / height;\n    /**\n     * Check if user is swiping down and\n     * if we have a canDismiss value that\n     * should block the gesture from\n     * proceeding,\n     */\n    const isAttemptingDismissWithCanDismiss = step >= 0 && canDismissBlocksGesture;\n    /**\n     * If we are blocking the gesture from dismissing,\n     * set the max step value so that the sheet cannot be\n     * completely hidden.\n     */\n    const maxStep = isAttemptingDismissWithCanDismiss ? canDismissMaxStep : 0.9999;\n    /**\n     * If we are blocking the gesture from\n     * dismissing, calculate the spring modifier value\n     * this will be added to the starting breakpoint\n     * value to give the gesture a spring-like feeling.\n     * Note that the starting breakpoint is always 0,\n     * so we omit adding 0 to the result.\n     */\n    const processedStep = isAttemptingDismissWithCanDismiss ? calculateSpringStep(step / maxStep) : step;\n    const clampedStep = clamp(0.0001, processedStep, maxStep);\n    animation.progressStep(clampedStep);\n    /**\n     * When swiping down half way, the status bar style\n     * should be reset to its default value.\n     *\n     * We track lastStep so that we do not fire these\n     * functions on every onMove, only when the user has\n     * crossed a certain threshold.\n     */\n    if (clampedStep >= DISMISS_THRESHOLD && lastStep < DISMISS_THRESHOLD) {\n      setCardStatusBarDefault(statusBarStyle);\n      /**\n       * However, if we swipe back up, then the\n       * status bar style should be set to have light\n       * text on a dark background.\n       */\n    }\n    else if (clampedStep < DISMISS_THRESHOLD && lastStep >= DISMISS_THRESHOLD) {\n      setCardStatusBarDark();\n    }\n    lastStep = clampedStep;\n  };\n  const onEnd = (detail) => {\n    const velocity = detail.velocityY;\n    const step = detail.deltaY / height;\n    const isAttemptingDismissWithCanDismiss = step >= 0 && canDismissBlocksGesture;\n    const maxStep = isAttemptingDismissWithCanDismiss ? canDismissMaxStep : 0.9999;\n    const processedStep = isAttemptingDismissWithCanDismiss ? calculateSpringStep(step / maxStep) : step;\n    const clampedStep = clamp(0.0001, processedStep, maxStep);\n    const threshold = (detail.deltaY + velocity * 1000) / height;\n    /**\n     * If canDismiss blocks\n     * the swipe gesture, then the\n     * animation can never complete until\n     * canDismiss is checked.\n     */\n    const shouldComplete = !isAttemptingDismissWithCanDismiss && threshold >= DISMISS_THRESHOLD;\n    let newStepValue = shouldComplete ? -0.001 : 0.001;\n    if (!shouldComplete) {\n      animation.easing('cubic-bezier(1, 0, 0.68, 0.28)');\n      newStepValue += getTimeGivenProgression([0, 0], [1, 0], [0.68, 0.28], [1, 1], clampedStep)[0];\n    }\n    else {\n      animation.easing('cubic-bezier(0.32, 0.72, 0, 1)');\n      newStepValue += getTimeGivenProgression([0, 0], [0.32, 0.72], [0, 1], [1, 1], clampedStep)[0];\n    }\n    const duration = shouldComplete\n      ? computeDuration(step * height, velocity)\n      : computeDuration((1 - clampedStep) * height, velocity);\n    isOpen = shouldComplete;\n    gesture.enable(false);\n    if (contentEl) {\n      resetContentScrollY(contentEl, initialScrollY);\n    }\n    animation\n      .onFinish(() => {\n      if (!shouldComplete) {\n        gesture.enable(true);\n      }\n    })\n      .progressEnd(shouldComplete ? 1 : 0, newStepValue, duration);\n    /**\n     * If the canDismiss value blocked the gesture\n     * from proceeding, then we should ignore whatever\n     * shouldComplete is. Whether or not the modal\n     * animation should complete is now determined by\n     * canDismiss.\n     *\n     * If the user swiped >25% of the way\n     * to the max step, then we should\n     * check canDismiss. 25% was chosen\n     * to avoid accidental swipes.\n     */\n    if (isAttemptingDismissWithCanDismiss && clampedStep > maxStep / 4) {\n      handleCanDismiss(el, animation);\n    }\n    else if (shouldComplete) {\n      onDismiss();\n    }\n  };\n  const gesture = createGesture({\n    el,\n    gestureName: 'modalSwipeToClose',\n    gesturePriority: 39,\n    direction: 'y',\n    threshold: 10,\n    canStart,\n    onStart,\n    onMove,\n    onEnd,\n  });\n  return gesture;\n};\nconst computeDuration = (remaining, velocity) => {\n  return clamp(400, remaining / Math.abs(velocity * 1.1), 500);\n};\n","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { createAnimation } from '../../../utils/animation/animation';\nimport { getBackdropValueForSheet } from '../utils';\nexport const createSheetEnterAnimation = (opts) => {\n  const { currentBreakpoint, backdropBreakpoint } = opts;\n  /**\n   * If the backdropBreakpoint is undefined, then the backdrop\n   * should always fade in. If the backdropBreakpoint came before the\n   * current breakpoint, then the backdrop should be fading in.\n   */\n  const shouldShowBackdrop = backdropBreakpoint === undefined || backdropBreakpoint < currentBreakpoint;\n  const initialBackdrop = shouldShowBackdrop ? `calc(var(--backdrop-opacity) * ${currentBreakpoint})` : '0';\n  const backdropAnimation = createAnimation('backdropAnimation').fromTo('opacity', 0, initialBackdrop);\n  if (shouldShowBackdrop) {\n    backdropAnimation\n      .beforeStyles({\n      'pointer-events': 'none',\n    })\n      .afterClearStyles(['pointer-events']);\n  }\n  const wrapperAnimation = createAnimation('wrapperAnimation').keyframes([\n    { offset: 0, opacity: 1, transform: 'translateY(100%)' },\n    { offset: 1, opacity: 1, transform: `translateY(${100 - currentBreakpoint * 100}%)` },\n  ]);\n  return { wrapperAnimation, backdropAnimation };\n};\nexport const createSheetLeaveAnimation = (opts) => {\n  const { currentBreakpoint, backdropBreakpoint } = opts;\n  /**\n   * Backdrop does not always fade in from 0 to 1 if backdropBreakpoint\n   * is defined, so we need to account for that offset by figuring out\n   * what the current backdrop value should be.\n   */\n  const backdropValue = `calc(var(--backdrop-opacity) * ${getBackdropValueForSheet(currentBreakpoint, backdropBreakpoint)})`;\n  const defaultBackdrop = [\n    { offset: 0, opacity: backdropValue },\n    { offset: 1, opacity: 0 },\n  ];\n  const customBackdrop = [\n    { offset: 0, opacity: backdropValue },\n    { offset: backdropBreakpoint, opacity: 0 },\n    { offset: 1, opacity: 0 },\n  ];\n  const backdropAnimation = createAnimation('backdropAnimation').keyframes(backdropBreakpoint !== 0 ? customBackdrop : defaultBackdrop);\n  const wrapperAnimation = createAnimation('wrapperAnimation').keyframes([\n    { offset: 0, opacity: 1, transform: `translateY(${100 - currentBreakpoint * 100}%)` },\n    { offset: 1, opacity: 1, transform: `translateY(100%)` },\n  ]);\n  return { wrapperAnimation, backdropAnimation };\n};\n","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { createAnimation } from '../../../utils/animation/animation';\nimport { getElementRoot } from '../../../utils/helpers';\nimport { SwipeToCloseDefaults } from '../gestures/swipe-to-close';\nimport { createSheetEnterAnimation } from './sheet';\nconst createEnterAnimation = () => {\n  const backdropAnimation = createAnimation()\n    .fromTo('opacity', 0.01, 'var(--backdrop-opacity)')\n    .beforeStyles({\n    'pointer-events': 'none',\n  })\n    .afterClearStyles(['pointer-events']);\n  const wrapperAnimation = createAnimation().fromTo('transform', 'translateY(100vh)', 'translateY(0vh)');\n  return { backdropAnimation, wrapperAnimation };\n};\n/**\n * iOS Modal Enter Animation for the Card presentation style\n */\nexport const iosEnterAnimation = (baseEl, opts) => {\n  const { presentingEl, currentBreakpoint } = opts;\n  const root = getElementRoot(baseEl);\n  const { wrapperAnimation, backdropAnimation } = currentBreakpoint !== undefined ? createSheetEnterAnimation(opts) : createEnterAnimation();\n  backdropAnimation.addElement(root.querySelector('ion-backdrop'));\n  wrapperAnimation.addElement(root.querySelectorAll('.modal-wrapper, .modal-shadow')).beforeStyles({ opacity: 1 });\n  const baseAnimation = createAnimation('entering-base')\n    .addElement(baseEl)\n    .easing('cubic-bezier(0.32,0.72,0,1)')\n    .duration(500)\n    .addAnimation(wrapperAnimation);\n  if (presentingEl) {\n    const isMobile = window.innerWidth < 768;\n    const hasCardModal = presentingEl.tagName === 'ION-MODAL' && presentingEl.presentingElement !== undefined;\n    const presentingElRoot = getElementRoot(presentingEl);\n    const presentingAnimation = createAnimation().beforeStyles({\n      transform: 'translateY(0)',\n      'transform-origin': 'top center',\n      overflow: 'hidden',\n    });\n    const bodyEl = document.body;\n    if (isMobile) {\n      /**\n       * Fallback for browsers that does not support `max()` (ex: Firefox)\n       * No need to worry about statusbar padding since engines like Gecko\n       * are not used as the engine for standalone Cordova/Capacitor apps\n       */\n      const transformOffset = !CSS.supports('width', 'max(0px, 1px)') ? '30px' : 'max(30px, var(--ion-safe-area-top))';\n      const modalTransform = hasCardModal ? '-10px' : transformOffset;\n      const toPresentingScale = SwipeToCloseDefaults.MIN_PRESENTING_SCALE;\n      const finalTransform = `translateY(${modalTransform}) scale(${toPresentingScale})`;\n      presentingAnimation\n        .afterStyles({\n        transform: finalTransform,\n      })\n        .beforeAddWrite(() => bodyEl.style.setProperty('background-color', 'black'))\n        .addElement(presentingEl)\n        .keyframes([\n        { offset: 0, filter: 'contrast(1)', transform: 'translateY(0px) scale(1)', borderRadius: '0px' },\n        { offset: 1, filter: 'contrast(0.85)', transform: finalTransform, borderRadius: '10px 10px 0 0' },\n      ]);\n      baseAnimation.addAnimation(presentingAnimation);\n    }\n    else {\n      baseAnimation.addAnimation(backdropAnimation);\n      if (!hasCardModal) {\n        wrapperAnimation.fromTo('opacity', '0', '1');\n      }\n      else {\n        const toPresentingScale = hasCardModal ? SwipeToCloseDefaults.MIN_PRESENTING_SCALE : 1;\n        const finalTransform = `translateY(-10px) scale(${toPresentingScale})`;\n        presentingAnimation\n          .afterStyles({\n          transform: finalTransform,\n        })\n          .addElement(presentingElRoot.querySelector('.modal-wrapper'))\n          .keyframes([\n          { offset: 0, filter: 'contrast(1)', transform: 'translateY(0) scale(1)' },\n          { offset: 1, filter: 'contrast(0.85)', transform: finalTransform },\n        ]);\n        const shadowAnimation = createAnimation()\n          .afterStyles({\n          transform: finalTransform,\n        })\n          .addElement(presentingElRoot.querySelector('.modal-shadow'))\n          .keyframes([\n          { offset: 0, opacity: '1', transform: 'translateY(0) scale(1)' },\n          { offset: 1, opacity: '0', transform: finalTransform },\n        ]);\n        baseAnimation.addAnimation([presentingAnimation, shadowAnimation]);\n      }\n    }\n  }\n  else {\n    baseAnimation.addAnimation(backdropAnimation);\n  }\n  return baseAnimation;\n};\n","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { createAnimation } from '../../../utils/animation/animation';\nimport { getElementRoot } from '../../../utils/helpers';\nimport { SwipeToCloseDefaults } from '../gestures/swipe-to-close';\nimport { createSheetLeaveAnimation } from './sheet';\nconst createLeaveAnimation = () => {\n  const backdropAnimation = createAnimation().fromTo('opacity', 'var(--backdrop-opacity)', 0);\n  const wrapperAnimation = createAnimation().fromTo('transform', 'translateY(0vh)', 'translateY(100vh)');\n  return { backdropAnimation, wrapperAnimation };\n};\n/**\n * iOS Modal Leave Animation\n */\nexport const iosLeaveAnimation = (baseEl, opts, duration = 500) => {\n  const { presentingEl, currentBreakpoint } = opts;\n  const root = getElementRoot(baseEl);\n  const { wrapperAnimation, backdropAnimation } = currentBreakpoint !== undefined ? createSheetLeaveAnimation(opts) : createLeaveAnimation();\n  backdropAnimation.addElement(root.querySelector('ion-backdrop'));\n  wrapperAnimation.addElement(root.querySelectorAll('.modal-wrapper, .modal-shadow')).beforeStyles({ opacity: 1 });\n  const baseAnimation = createAnimation('leaving-base')\n    .addElement(baseEl)\n    .easing('cubic-bezier(0.32,0.72,0,1)')\n    .duration(duration)\n    .addAnimation(wrapperAnimation);\n  if (presentingEl) {\n    const isMobile = window.innerWidth < 768;\n    const hasCardModal = presentingEl.tagName === 'ION-MODAL' && presentingEl.presentingElement !== undefined;\n    const presentingElRoot = getElementRoot(presentingEl);\n    const presentingAnimation = createAnimation()\n      .beforeClearStyles(['transform'])\n      .afterClearStyles(['transform'])\n      .onFinish((currentStep) => {\n      // only reset background color if this is the last card-style modal\n      if (currentStep !== 1) {\n        return;\n      }\n      presentingEl.style.setProperty('overflow', '');\n      const numModals = Array.from(bodyEl.querySelectorAll('ion-modal')).filter((m) => m.presentingElement !== undefined).length;\n      if (numModals <= 1) {\n        bodyEl.style.setProperty('background-color', '');\n      }\n    });\n    const bodyEl = document.body;\n    if (isMobile) {\n      const transformOffset = !CSS.supports('width', 'max(0px, 1px)') ? '30px' : 'max(30px, var(--ion-safe-area-top))';\n      const modalTransform = hasCardModal ? '-10px' : transformOffset;\n      const toPresentingScale = SwipeToCloseDefaults.MIN_PRESENTING_SCALE;\n      const finalTransform = `translateY(${modalTransform}) scale(${toPresentingScale})`;\n      presentingAnimation.addElement(presentingEl).keyframes([\n        { offset: 0, filter: 'contrast(0.85)', transform: finalTransform, borderRadius: '10px 10px 0 0' },\n        { offset: 1, filter: 'contrast(1)', transform: 'translateY(0px) scale(1)', borderRadius: '0px' },\n      ]);\n      baseAnimation.addAnimation(presentingAnimation);\n    }\n    else {\n      baseAnimation.addAnimation(backdropAnimation);\n      if (!hasCardModal) {\n        wrapperAnimation.fromTo('opacity', '1', '0');\n      }\n      else {\n        const toPresentingScale = hasCardModal ? SwipeToCloseDefaults.MIN_PRESENTING_SCALE : 1;\n        const finalTransform = `translateY(-10px) scale(${toPresentingScale})`;\n        presentingAnimation\n          .addElement(presentingElRoot.querySelector('.modal-wrapper'))\n          .afterStyles({\n          transform: 'translate3d(0, 0, 0)',\n        })\n          .keyframes([\n          { offset: 0, filter: 'contrast(0.85)', transform: finalTransform },\n          { offset: 1, filter: 'contrast(1)', transform: 'translateY(0) scale(1)' },\n        ]);\n        const shadowAnimation = createAnimation()\n          .addElement(presentingElRoot.querySelector('.modal-shadow'))\n          .afterStyles({\n          transform: 'translateY(0) scale(1)',\n        })\n          .keyframes([\n          { offset: 0, opacity: '0', transform: finalTransform },\n          { offset: 1, opacity: '1', transform: 'translateY(0) scale(1)' },\n        ]);\n        baseAnimation.addAnimation([presentingAnimation, shadowAnimation]);\n      }\n    }\n  }\n  else {\n    baseAnimation.addAnimation(backdropAnimation);\n  }\n  return baseAnimation;\n};\n","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { createAnimation } from '../../../utils/animation/animation';\nimport { getElementRoot } from '../../../utils/helpers';\nimport { createSheetEnterAnimation } from './sheet';\nconst createEnterAnimation = () => {\n  const backdropAnimation = createAnimation()\n    .fromTo('opacity', 0.01, 'var(--backdrop-opacity)')\n    .beforeStyles({\n    'pointer-events': 'none',\n  })\n    .afterClearStyles(['pointer-events']);\n  const wrapperAnimation = createAnimation().keyframes([\n    { offset: 0, opacity: 0.01, transform: 'translateY(40px)' },\n    { offset: 1, opacity: 1, transform: `translateY(0px)` },\n  ]);\n  return { backdropAnimation, wrapperAnimation };\n};\n/**\n * Md Modal Enter Animation\n */\nexport const mdEnterAnimation = (baseEl, opts) => {\n  const { currentBreakpoint } = opts;\n  const root = getElementRoot(baseEl);\n  const { wrapperAnimation, backdropAnimation } = currentBreakpoint !== undefined ? createSheetEnterAnimation(opts) : createEnterAnimation();\n  backdropAnimation.addElement(root.querySelector('ion-backdrop'));\n  wrapperAnimation.addElement(root.querySelector('.modal-wrapper'));\n  return createAnimation()\n    .addElement(baseEl)\n    .easing('cubic-bezier(0.36,0.66,0.04,1)')\n    .duration(280)\n    .addAnimation([backdropAnimation, wrapperAnimation]);\n};\n","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { createAnimation } from '../../../utils/animation/animation';\nimport { getElementRoot } from '../../../utils/helpers';\nimport { createSheetLeaveAnimation } from './sheet';\nconst createLeaveAnimation = () => {\n  const backdropAnimation = createAnimation().fromTo('opacity', 'var(--backdrop-opacity)', 0);\n  const wrapperAnimation = createAnimation().keyframes([\n    { offset: 0, opacity: 0.99, transform: `translateY(0px)` },\n    { offset: 1, opacity: 0, transform: 'translateY(40px)' },\n  ]);\n  return { backdropAnimation, wrapperAnimation };\n};\n/**\n * Md Modal Leave Animation\n */\nexport const mdLeaveAnimation = (baseEl, opts) => {\n  const { currentBreakpoint } = opts;\n  const root = getElementRoot(baseEl);\n  const { wrapperAnimation, backdropAnimation } = currentBreakpoint !== undefined ? createSheetLeaveAnimation(opts) : createLeaveAnimation();\n  backdropAnimation.addElement(root.querySelector('ion-backdrop'));\n  wrapperAnimation.addElement(root.querySelector('.modal-wrapper'));\n  return createAnimation()\n    .easing('cubic-bezier(0.47,0,0.745,0.715)')\n    .duration(200)\n    .addAnimation([backdropAnimation, wrapperAnimation]);\n};\n","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { createGesture } from '../../../utils/gesture';\nimport { clamp, raf } from '../../../utils/helpers';\nimport { getBackdropValueForSheet } from '../utils';\nimport { calculateSpringStep, handleCanDismiss } from './utils';\nexport const createSheetGesture = (baseEl, backdropEl, wrapperEl, initialBreakpoint, backdropBreakpoint, animation, breakpoints = [], getCurrentBreakpoint, onDismiss, onBreakpointChange) => {\n  // Defaults for the sheet swipe animation\n  const defaultBackdrop = [\n    { offset: 0, opacity: 'var(--backdrop-opacity)' },\n    { offset: 1, opacity: 0.01 },\n  ];\n  const customBackdrop = [\n    { offset: 0, opacity: 'var(--backdrop-opacity)' },\n    { offset: 1 - backdropBreakpoint, opacity: 0 },\n    { offset: 1, opacity: 0 },\n  ];\n  const SheetDefaults = {\n    WRAPPER_KEYFRAMES: [\n      { offset: 0, transform: 'translateY(0%)' },\n      { offset: 1, transform: 'translateY(100%)' },\n    ],\n    BACKDROP_KEYFRAMES: backdropBreakpoint !== 0 ? customBackdrop : defaultBackdrop,\n  };\n  const contentEl = baseEl.querySelector('ion-content');\n  const height = wrapperEl.clientHeight;\n  let currentBreakpoint = initialBreakpoint;\n  let offset = 0;\n  let canDismissBlocksGesture = false;\n  const canDismissMaxStep = 0.95;\n  const wrapperAnimation = animation.childAnimations.find((ani) => ani.id === 'wrapperAnimation');\n  const backdropAnimation = animation.childAnimations.find((ani) => ani.id === 'backdropAnimation');\n  const maxBreakpoint = breakpoints[breakpoints.length - 1];\n  const minBreakpoint = breakpoints[0];\n  const enableBackdrop = () => {\n    baseEl.style.setProperty('pointer-events', 'auto');\n    backdropEl.style.setProperty('pointer-events', 'auto');\n    /**\n     * When the backdrop is enabled, elements such\n     * as inputs should not be focusable outside\n     * the sheet.\n     */\n    baseEl.classList.remove('ion-disable-focus-trap');\n  };\n  const disableBackdrop = () => {\n    baseEl.style.setProperty('pointer-events', 'none');\n    backdropEl.style.setProperty('pointer-events', 'none');\n    /**\n     * When the backdrop is enabled, elements such\n     * as inputs should not be focusable outside\n     * the sheet.\n     * Adding this class disables focus trapping\n     * for the sheet temporarily.\n     */\n    baseEl.classList.add('ion-disable-focus-trap');\n  };\n  /**\n   * After the entering animation completes,\n   * we need to set the animation to go from\n   * offset 0 to offset 1 so that users can\n   * swipe in any direction. We then set the\n   * animation offset to the current breakpoint\n   * so there is no flickering.\n   */\n  if (wrapperAnimation && backdropAnimation) {\n    wrapperAnimation.keyframes([...SheetDefaults.WRAPPER_KEYFRAMES]);\n    backdropAnimation.keyframes([...SheetDefaults.BACKDROP_KEYFRAMES]);\n    animation.progressStart(true, 1 - currentBreakpoint);\n    /**\n     * If backdrop is not enabled, then content\n     * behind modal should be clickable. To do this, we need\n     * to remove pointer-events from ion-modal as a whole.\n     * ion-backdrop and .modal-wrapper always have pointer-events: auto\n     * applied, so the modal content can still be interacted with.\n     */\n    const shouldEnableBackdrop = currentBreakpoint > backdropBreakpoint;\n    if (shouldEnableBackdrop) {\n      enableBackdrop();\n    }\n    else {\n      disableBackdrop();\n    }\n  }\n  if (contentEl && currentBreakpoint !== maxBreakpoint) {\n    contentEl.scrollY = false;\n  }\n  const canStart = (detail) => {\n    /**\n     * If the sheet is fully expanded and\n     * the user is swiping on the content,\n     * the gesture should not start to\n     * allow for scrolling on the content.\n     */\n    const content = detail.event.target.closest('ion-content');\n    currentBreakpoint = getCurrentBreakpoint();\n    if (currentBreakpoint === 1 && content) {\n      return false;\n    }\n    return true;\n  };\n  const onStart = () => {\n    /**\n     * If canDismiss is anything other than `true`\n     * then users should be able to swipe down\n     * until a threshold is hit. At that point,\n     * the card modal should not proceed any further.\n     *\n     * canDismiss is never fired via gesture if there is\n     * no 0 breakpoint. However, it can be fired if the user\n     * presses Esc or the hardware back button.\n     * TODO (FW-937)\n     * Remove undefined check\n     */\n    canDismissBlocksGesture = baseEl.canDismiss !== undefined && baseEl.canDismiss !== true && minBreakpoint === 0;\n    /**\n     * If swiping on the content\n     * we should disable scrolling otherwise\n     * the sheet will expand and the content will scroll.\n     */\n    if (contentEl) {\n      contentEl.scrollY = false;\n    }\n    raf(() => {\n      /**\n       * Dismisses the open keyboard when the sheet drag gesture is started.\n       * Sets the focus onto the modal element.\n       */\n      baseEl.focus();\n    });\n    animation.progressStart(true, 1 - currentBreakpoint);\n  };\n  const onMove = (detail) => {\n    /**\n     * Given the change in gesture position on the Y axis,\n     * compute where the offset of the animation should be\n     * relative to where the user dragged.\n     */\n    const initialStep = 1 - currentBreakpoint;\n    const secondToLastBreakpoint = breakpoints.length > 1 ? 1 - breakpoints[1] : undefined;\n    const step = initialStep + detail.deltaY / height;\n    const isAttemptingDismissWithCanDismiss = secondToLastBreakpoint !== undefined && step >= secondToLastBreakpoint && canDismissBlocksGesture;\n    /**\n     * If we are blocking the gesture from dismissing,\n     * set the max step value so that the sheet cannot be\n     * completely hidden.\n     */\n    const maxStep = isAttemptingDismissWithCanDismiss ? canDismissMaxStep : 0.9999;\n    /**\n     * If we are blocking the gesture from\n     * dismissing, calculate the spring modifier value\n     * this will be added to the starting breakpoint\n     * value to give the gesture a spring-like feeling.\n     * Note that when isAttemptingDismissWithCanDismiss is true,\n     * the modifier is always added to the breakpoint that\n     * appears right after the 0 breakpoint.\n     *\n     * Note that this modifier is essentially the progression\n     * between secondToLastBreakpoint and maxStep which is\n     * why we subtract secondToLastBreakpoint. This lets us get\n     * the result as a value from 0 to 1.\n     */\n    const processedStep = isAttemptingDismissWithCanDismiss && secondToLastBreakpoint !== undefined\n      ? secondToLastBreakpoint +\n        calculateSpringStep((step - secondToLastBreakpoint) / (maxStep - secondToLastBreakpoint))\n      : step;\n    offset = clamp(0.0001, processedStep, maxStep);\n    animation.progressStep(offset);\n  };\n  const onEnd = (detail) => {\n    /**\n     * When the gesture releases, we need to determine\n     * the closest breakpoint to snap to.\n     */\n    const velocity = detail.velocityY;\n    const threshold = (detail.deltaY + velocity * 350) / height;\n    const diff = currentBreakpoint - threshold;\n    const closest = breakpoints.reduce((a, b) => {\n      return Math.abs(b - diff) < Math.abs(a - diff) ? b : a;\n    });\n    moveSheetToBreakpoint({\n      breakpoint: closest,\n      breakpointOffset: offset,\n      canDismiss: canDismissBlocksGesture,\n    });\n  };\n  const moveSheetToBreakpoint = (options) => {\n    const { breakpoint, canDismiss, breakpointOffset } = options;\n    /**\n     * canDismiss should only prevent snapping\n     * when users are trying to dismiss. If canDismiss\n     * is present but the user is trying to swipe upwards,\n     * we should allow that to happen,\n     */\n    const shouldPreventDismiss = canDismiss && breakpoint === 0;\n    const snapToBreakpoint = shouldPreventDismiss ? currentBreakpoint : breakpoint;\n    const shouldRemainOpen = snapToBreakpoint !== 0;\n    currentBreakpoint = 0;\n    /**\n     * Update the animation so that it plays from\n     * the last offset to the closest snap point.\n     */\n    if (wrapperAnimation && backdropAnimation) {\n      wrapperAnimation.keyframes([\n        { offset: 0, transform: `translateY(${breakpointOffset * 100}%)` },\n        { offset: 1, transform: `translateY(${(1 - snapToBreakpoint) * 100}%)` },\n      ]);\n      backdropAnimation.keyframes([\n        {\n          offset: 0,\n          opacity: `calc(var(--backdrop-opacity) * ${getBackdropValueForSheet(1 - breakpointOffset, backdropBreakpoint)})`,\n        },\n        {\n          offset: 1,\n          opacity: `calc(var(--backdrop-opacity) * ${getBackdropValueForSheet(snapToBreakpoint, backdropBreakpoint)})`,\n        },\n      ]);\n      animation.progressStep(0);\n    }\n    /**\n     * Gesture should remain disabled until the\n     * snapping animation completes.\n     */\n    gesture.enable(false);\n    if (shouldPreventDismiss) {\n      handleCanDismiss(baseEl, animation);\n    }\n    else if (!shouldRemainOpen) {\n      onDismiss();\n    }\n    return new Promise((resolve) => {\n      animation\n        .onFinish(() => {\n        if (shouldRemainOpen) {\n          /**\n           * Once the snapping animation completes,\n           * we need to reset the animation to go\n           * from 0 to 1 so users can swipe in any direction.\n           * We then set the animation offset to the current\n           * breakpoint so that it starts at the snapped position.\n           */\n          if (wrapperAnimation && backdropAnimation) {\n            raf(() => {\n              wrapperAnimation.keyframes([...SheetDefaults.WRAPPER_KEYFRAMES]);\n              backdropAnimation.keyframes([...SheetDefaults.BACKDROP_KEYFRAMES]);\n              animation.progressStart(true, 1 - snapToBreakpoint);\n              currentBreakpoint = snapToBreakpoint;\n              onBreakpointChange(currentBreakpoint);\n              /**\n               * If the sheet is fully expanded, we can safely\n               * enable scrolling again.\n               */\n              if (contentEl && currentBreakpoint === breakpoints[breakpoints.length - 1]) {\n                contentEl.scrollY = true;\n              }\n              /**\n               * Backdrop should become enabled\n               * after the backdropBreakpoint value\n               */\n              const shouldEnableBackdrop = currentBreakpoint > backdropBreakpoint;\n              if (shouldEnableBackdrop) {\n                enableBackdrop();\n              }\n              else {\n                disableBackdrop();\n              }\n              gesture.enable(true);\n              resolve();\n            });\n          }\n          else {\n            gesture.enable(true);\n            resolve();\n          }\n        }\n        else {\n          resolve();\n        }\n        /**\n         * This must be a one time callback\n         * otherwise a new callback will\n         * be added every time onEnd runs.\n         */\n      }, { oneTimeCallback: true })\n        .progressEnd(1, 0, 500);\n    });\n  };\n  const gesture = createGesture({\n    el: wrapperEl,\n    gestureName: 'modalSheet',\n    gesturePriority: 40,\n    direction: 'y',\n    threshold: 10,\n    canStart,\n    onStart,\n    onMove,\n    onEnd,\n  });\n  return {\n    gesture,\n    moveSheetToBreakpoint,\n  };\n};\n",":host {\n  /**\n   * @prop --background: Background of the modal content\n   *\n   * @prop --border-color: Border color of the modal content\n   * @prop --border-radius: Border radius of the modal content\n   * @prop --border-width: Border width of the modal content\n   * @prop --border-style: Border style of the modal content\n   *\n   * @prop --min-width: Minimum width of the modal\n   * @prop --width: Width of the modal\n   * @prop --max-width: Maximum width of the modal\n   *\n   * @prop --min-height: Minimum height of the modal\n   * @prop --height: Height of the modal\n   * @prop --max-height: Maximum height of the modal\n   *\n   * @prop --backdrop-opacity: Opacity of the backdrop\n   */\n  --width: 100%;\n  --min-width: auto;\n  --max-width: auto;\n  --height: 100%;\n  --min-height: auto;\n  --max-height: auto;\n  --overflow: hidden;\n  --border-radius: 0;\n  --border-width: 0;\n  --border-style: none;\n  --border-color: transparent;\n  --background: var(--ion-background-color, #fff);\n  --box-shadow: none;\n  --backdrop-opacity: 0;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  display: flex;\n  position: absolute;\n  align-items: center;\n  justify-content: center;\n  outline: none;\n  contain: strict;\n}\n\n.modal-wrapper,\nion-backdrop {\n  pointer-events: auto;\n}\n\n:host(.overlay-hidden) {\n  display: none;\n}\n\n.modal-wrapper,\n.modal-shadow {\n  border-radius: var(--border-radius);\n  width: var(--width);\n  min-width: var(--min-width);\n  max-width: var(--max-width);\n  height: var(--height);\n  min-height: var(--min-height);\n  max-height: var(--max-height);\n  border-width: var(--border-width);\n  border-style: var(--border-style);\n  border-color: var(--border-color);\n  background: var(--background);\n  box-shadow: var(--box-shadow);\n  overflow: var(--overflow);\n  z-index: 10;\n}\n\n.modal-shadow {\n  position: absolute;\n  background: transparent;\n}\n\n@media only screen and (min-width: 768px) and (min-height: 600px) {\n  :host {\n    --width: 600px;\n    --height: 500px;\n    --ion-safe-area-top: 0px;\n    --ion-safe-area-bottom: 0px;\n    --ion-safe-area-right: 0px;\n    --ion-safe-area-left: 0px;\n  }\n}\n@media only screen and (min-width: 768px) and (min-height: 768px) {\n  :host {\n    --width: 600px;\n    --height: 600px;\n  }\n}\n.modal-handle {\n  left: 0px;\n  right: 0px;\n  top: 5px;\n  border-radius: 8px;\n  margin-left: auto;\n  margin-right: auto;\n  position: absolute;\n  width: 36px;\n  height: 5px;\n  /**\n   * This allows the handle to appear\n   * on top of user content in WebKit.\n   */\n  transform: translateZ(0);\n  border: 0;\n  background: var(--ion-color-step-350, #c0c0be);\n  cursor: pointer;\n  z-index: 11;\n}\n@supports (margin-inline-start: 0) or (-webkit-margin-start: 0) {\n  .modal-handle {\n    margin-left: unset;\n    margin-right: unset;\n    -webkit-margin-start: auto;\n    margin-inline-start: auto;\n    -webkit-margin-end: auto;\n    margin-inline-end: auto;\n  }\n}\n.modal-handle::before {\n  /**\n   * Adds a 4px tap area to the perimeter\n   * of the handle.\n   */\n  padding-left: 4px;\n  padding-right: 4px;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  position: absolute;\n  width: 36px;\n  height: 5px;\n  transform: translate(-50%, -50%);\n  content: \"\";\n}\n@supports (margin-inline-start: 0) or (-webkit-margin-start: 0) {\n  .modal-handle::before {\n    padding-left: unset;\n    padding-right: unset;\n    -webkit-padding-start: 4px;\n    padding-inline-start: 4px;\n    -webkit-padding-end: 4px;\n    padding-inline-end: 4px;\n  }\n}\n\n/**\n * Ensure that the sheet modal does not\n * completely cover the content.\n */\n:host(.modal-sheet) {\n  --height: calc(100% - (var(--ion-safe-area-top) + 10px));\n}\n\n:host(.modal-sheet) .modal-wrapper,\n:host(.modal-sheet) .modal-shadow {\n  position: absolute;\n  bottom: 0;\n}\n\n:host {\n  --backdrop-opacity: var(--ion-backdrop-opacity, 0.4);\n}\n\n:host(.modal-card),\n:host(.modal-sheet) {\n  --border-radius: 10px;\n}\n\n@media only screen and (min-width: 768px) and (min-height: 600px) {\n  :host {\n    --border-radius: 10px;\n  }\n}\n.modal-wrapper {\n  transform: translate3d(0,  100%,  0);\n}\n\n@media screen and (max-width: 767px) {\n  @supports (width: 1px) {\n    :host(.modal-card) {\n      --height: calc(100% - max(30px, var(--ion-safe-area-top)) - 10px);\n    }\n  }\n  @supports not (width: 1px) {\n    :host(.modal-card) {\n      --height: calc(100% - 40px);\n    }\n  }\n  :host(.modal-card) .modal-wrapper {\n    border-top-left-radius: var(--border-radius);\n    border-top-right-radius: var(--border-radius);\n    border-bottom-right-radius: 0;\n    border-bottom-left-radius: 0;\n  }\n  :host-context([dir=rtl]):host(.modal-card) .modal-wrapper, :host-context([dir=rtl]).modal-card .modal-wrapper {\n    border-top-left-radius: var(--border-radius);\n    border-top-right-radius: var(--border-radius);\n    border-bottom-right-radius: 0;\n    border-bottom-left-radius: 0;\n  }\n\n  :host(.modal-card) {\n    --backdrop-opacity: 0;\n    --width: 100%;\n    align-items: flex-end;\n  }\n\n  :host(.modal-card) .modal-shadow {\n    display: none;\n  }\n\n  :host(.modal-card) ion-backdrop {\n    pointer-events: none;\n  }\n}\n@media screen and (min-width: 768px) {\n  :host(.modal-card) {\n    --width: calc(100% - 120px);\n    --height: calc(100% - (120px + var(--ion-safe-area-top) + var(--ion-safe-area-bottom)));\n    --max-width: 720px;\n    --max-height: 1000px;\n    --backdrop-opacity: 0;\n    --box-shadow: 0px 0px 30px 10px rgba(0, 0, 0, 0.1);\n    transition: all 0.5s ease-in-out;\n  }\n\n  :host(.modal-card) .modal-wrapper {\n    box-shadow: none;\n  }\n\n  :host(.modal-card) .modal-shadow {\n    box-shadow: var(--box-shadow);\n  }\n}\n:host(.modal-sheet) .modal-wrapper {\n  border-top-left-radius: var(--border-radius);\n  border-top-right-radius: var(--border-radius);\n  border-bottom-right-radius: 0;\n  border-bottom-left-radius: 0;\n}\n:host-context([dir=rtl]):host(.modal-sheet) .modal-wrapper, :host-context([dir=rtl]).modal-sheet .modal-wrapper {\n  border-top-left-radius: var(--border-radius);\n  border-top-right-radius: var(--border-radius);\n  border-bottom-right-radius: 0;\n  border-bottom-left-radius: 0;\n}",":host {\n  /**\n   * @prop --background: Background of the modal content\n   *\n   * @prop --border-color: Border color of the modal content\n   * @prop --border-radius: Border radius of the modal content\n   * @prop --border-width: Border width of the modal content\n   * @prop --border-style: Border style of the modal content\n   *\n   * @prop --min-width: Minimum width of the modal\n   * @prop --width: Width of the modal\n   * @prop --max-width: Maximum width of the modal\n   *\n   * @prop --min-height: Minimum height of the modal\n   * @prop --height: Height of the modal\n   * @prop --max-height: Maximum height of the modal\n   *\n   * @prop --backdrop-opacity: Opacity of the backdrop\n   */\n  --width: 100%;\n  --min-width: auto;\n  --max-width: auto;\n  --height: 100%;\n  --min-height: auto;\n  --max-height: auto;\n  --overflow: hidden;\n  --border-radius: 0;\n  --border-width: 0;\n  --border-style: none;\n  --border-color: transparent;\n  --background: var(--ion-background-color, #fff);\n  --box-shadow: none;\n  --backdrop-opacity: 0;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  display: flex;\n  position: absolute;\n  align-items: center;\n  justify-content: center;\n  outline: none;\n  contain: strict;\n}\n\n.modal-wrapper,\nion-backdrop {\n  pointer-events: auto;\n}\n\n:host(.overlay-hidden) {\n  display: none;\n}\n\n.modal-wrapper,\n.modal-shadow {\n  border-radius: var(--border-radius);\n  width: var(--width);\n  min-width: var(--min-width);\n  max-width: var(--max-width);\n  height: var(--height);\n  min-height: var(--min-height);\n  max-height: var(--max-height);\n  border-width: var(--border-width);\n  border-style: var(--border-style);\n  border-color: var(--border-color);\n  background: var(--background);\n  box-shadow: var(--box-shadow);\n  overflow: var(--overflow);\n  z-index: 10;\n}\n\n.modal-shadow {\n  position: absolute;\n  background: transparent;\n}\n\n@media only screen and (min-width: 768px) and (min-height: 600px) {\n  :host {\n    --width: 600px;\n    --height: 500px;\n    --ion-safe-area-top: 0px;\n    --ion-safe-area-bottom: 0px;\n    --ion-safe-area-right: 0px;\n    --ion-safe-area-left: 0px;\n  }\n}\n@media only screen and (min-width: 768px) and (min-height: 768px) {\n  :host {\n    --width: 600px;\n    --height: 600px;\n  }\n}\n.modal-handle {\n  left: 0px;\n  right: 0px;\n  top: 5px;\n  border-radius: 8px;\n  margin-left: auto;\n  margin-right: auto;\n  position: absolute;\n  width: 36px;\n  height: 5px;\n  /**\n   * This allows the handle to appear\n   * on top of user content in WebKit.\n   */\n  transform: translateZ(0);\n  border: 0;\n  background: var(--ion-color-step-350, #c0c0be);\n  cursor: pointer;\n  z-index: 11;\n}\n@supports (margin-inline-start: 0) or (-webkit-margin-start: 0) {\n  .modal-handle {\n    margin-left: unset;\n    margin-right: unset;\n    -webkit-margin-start: auto;\n    margin-inline-start: auto;\n    -webkit-margin-end: auto;\n    margin-inline-end: auto;\n  }\n}\n.modal-handle::before {\n  /**\n   * Adds a 4px tap area to the perimeter\n   * of the handle.\n   */\n  padding-left: 4px;\n  padding-right: 4px;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  position: absolute;\n  width: 36px;\n  height: 5px;\n  transform: translate(-50%, -50%);\n  content: \"\";\n}\n@supports (margin-inline-start: 0) or (-webkit-margin-start: 0) {\n  .modal-handle::before {\n    padding-left: unset;\n    padding-right: unset;\n    -webkit-padding-start: 4px;\n    padding-inline-start: 4px;\n    -webkit-padding-end: 4px;\n    padding-inline-end: 4px;\n  }\n}\n\n/**\n * Ensure that the sheet modal does not\n * completely cover the content.\n */\n:host(.modal-sheet) {\n  --height: calc(100% - (var(--ion-safe-area-top) + 10px));\n}\n\n:host(.modal-sheet) .modal-wrapper,\n:host(.modal-sheet) .modal-shadow {\n  position: absolute;\n  bottom: 0;\n}\n\n:host {\n  --backdrop-opacity: var(--ion-backdrop-opacity, 0.32);\n}\n\n@media only screen and (min-width: 768px) and (min-height: 600px) {\n  :host {\n    --border-radius: 2px;\n    --box-shadow: 0 28px 48px rgba(0, 0, 0, 0.4);\n  }\n}\n.modal-wrapper {\n  transform: translate3d(0,  40px,  0);\n  opacity: 0.01;\n}","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { Host, h, writeTask } from '@stencil/core';\nimport { config } from '../../global/config';\nimport { getIonMode } from '../../global/ionic-global';\nimport { findIonContent, printIonContentErrorMsg } from '../../utils/content';\nimport { CoreDelegate, attachComponent, detachComponent } from '../../utils/framework-delegate';\nimport { raf, inheritAttributes } from '../../utils/helpers';\nimport { KEYBOARD_DID_OPEN } from '../../utils/keyboard/keyboard';\nimport { printIonWarning } from '../../utils/logging';\nimport { Style as StatusBarStyle, StatusBar } from '../../utils/native/status-bar';\nimport { GESTURE, BACKDROP, activeAnimations, dismiss, eventMethod, prepareOverlay, present, } from '../../utils/overlays';\nimport { getClassMap } from '../../utils/theme';\nimport { deepReady } from '../../utils/transition';\nimport { iosEnterAnimation } from './animations/ios.enter';\nimport { iosLeaveAnimation } from './animations/ios.leave';\nimport { mdEnterAnimation } from './animations/md.enter';\nimport { mdLeaveAnimation } from './animations/md.leave';\nimport { createSheetGesture } from './gestures/sheet';\nimport { createSwipeToCloseGesture } from './gestures/swipe-to-close';\nimport { setCardStatusBarDark, setCardStatusBarDefault } from './utils';\n// TODO(FW-2832): types\n/**\n * @virtualProp {\"ios\" | \"md\"} mode - The mode determines which platform styles to use.\n *\n * @slot - Content is placed inside of the `.modal-content` element.\n *\n * @part backdrop - The `ion-backdrop` element.\n * @part content - The wrapper element for the default slot.\n * @part handle - The handle that is displayed at the top of the sheet modal when `handle=\"true\"`.\n */\nexport class Modal {\n  constructor() {\n    this.modalIndex = modalIds++;\n    this.coreDelegate = CoreDelegate();\n    this.isSheetModal = false;\n    this.inheritedAttributes = {};\n    this.inline = false;\n    // Whether or not modal is being dismissed via gesture\n    this.gestureAnimationDismissing = false;\n    this.presented = false;\n    /** @internal */\n    this.hasController = false;\n    /**\n     * If `true`, the keyboard will be automatically dismissed when the overlay is presented.\n     */\n    this.keyboardClose = true;\n    /**\n     * A decimal value between 0 and 1 that indicates the\n     * point after which the backdrop will begin to fade in\n     * when using a sheet modal. Prior to this point, the\n     * backdrop will be hidden and the content underneath\n     * the sheet can be interacted with. This value is exclusive\n     * meaning the backdrop will become active after the value\n     * specified.\n     */\n    this.backdropBreakpoint = 0;\n    /**\n     * The interaction behavior for the sheet modal when the handle is pressed.\n     *\n     * Defaults to `\"none\"`, which  means the modal will not change size or position when the handle is pressed.\n     * Set to `\"cycle\"` to let the modal cycle between available breakpoints when pressed.\n     *\n     * Handle behavior is unavailable when the `handle` property is set to `false` or\n     * when the `breakpoints` property is not set (using a fullscreen or card modal).\n     */\n    this.handleBehavior = 'none';\n    /**\n     * If `true`, the modal will be dismissed when the backdrop is clicked.\n     */\n    this.backdropDismiss = true;\n    /**\n     * If `true`, a backdrop will be displayed behind the modal.\n     * This property controls whether or not the backdrop\n     * darkens the screen when the modal is presented.\n     * It does not control whether or not the backdrop\n     * is active or present in the DOM.\n     */\n    this.showBackdrop = true;\n    /**\n     * If `true`, the modal will animate.\n     */\n    this.animated = true;\n    /**\n     * If `true`, the modal can be swiped to dismiss. Only applies in iOS mode.\n     * @deprecated - To prevent modals from dismissing, use canDismiss instead.\n     */\n    this.swipeToClose = false;\n    /**\n     * If `true`, the modal will open. If `false`, the modal will close.\n     * Use this if you need finer grained control over presentation, otherwise\n     * just use the modalController or the `trigger` property.\n     * Note: `isOpen` will not automatically be set back to `false` when\n     * the modal dismisses. You will need to do that in your code.\n     */\n    this.isOpen = false;\n    /**\n     * If `true`, the component passed into `ion-modal` will\n     * automatically be mounted when the modal is created. The\n     * component will remain mounted even when the modal is dismissed.\n     * However, the component will be destroyed when the modal is\n     * destroyed. This property is not reactive and should only be\n     * used when initially creating a modal.\n     *\n     * Note: This feature only applies to inline modals in JavaScript\n     * frameworks such as Angular, React, and Vue.\n     */\n    this.keepContentsMounted = false;\n    this.configureTriggerInteraction = () => {\n      const { trigger, el, destroyTriggerInteraction } = this;\n      if (destroyTriggerInteraction) {\n        destroyTriggerInteraction();\n      }\n      if (trigger === undefined) {\n        return;\n      }\n      const triggerEl = trigger !== undefined ? document.getElementById(trigger) : null;\n      if (!triggerEl) {\n        printIonWarning(`A trigger element with the ID \"${trigger}\" was not found in the DOM. The trigger element must be in the DOM when the \"trigger\" property is set on ion-modal.`, this.el);\n        return;\n      }\n      const configureTriggerInteraction = (trigEl, modalEl) => {\n        const openModal = () => {\n          modalEl.present();\n        };\n        trigEl.addEventListener('click', openModal);\n        return () => {\n          trigEl.removeEventListener('click', openModal);\n        };\n      };\n      this.destroyTriggerInteraction = configureTriggerInteraction(triggerEl, el);\n    };\n    this.onHandleClick = () => {\n      const { sheetTransition, handleBehavior } = this;\n      if (handleBehavior !== 'cycle' || sheetTransition !== undefined) {\n        /**\n         * The sheet modal should not advance to the next breakpoint\n         * if the handle behavior is not `cycle` or if the handle\n         * is clicked while the sheet is moving to a breakpoint.\n         */\n        return;\n      }\n      this.moveToNextBreakpoint();\n    };\n    this.onBackdropTap = () => {\n      const { sheetTransition } = this;\n      if (sheetTransition !== undefined) {\n        /**\n         * When the handle is double clicked at the largest breakpoint,\n         * it will start to move to the first breakpoint. While transitioning,\n         * the backdrop will often receive the second click. We prevent the\n         * backdrop from dismissing the modal while moving between breakpoints.\n         */\n        return;\n      }\n      this.dismiss(undefined, BACKDROP);\n    };\n    this.onLifecycle = (modalEvent) => {\n      const el = this.usersElement;\n      const name = LIFECYCLE_MAP[modalEvent.type];\n      if (el && name) {\n        const ev = new CustomEvent(name, {\n          bubbles: false,\n          cancelable: false,\n          detail: modalEvent.detail,\n        });\n        el.dispatchEvent(ev);\n      }\n    };\n  }\n  onIsOpenChange(newValue, oldValue) {\n    if (newValue === true && oldValue === false) {\n      this.present();\n    }\n    else if (newValue === false && oldValue === true) {\n      this.dismiss();\n    }\n  }\n  onTriggerChange() {\n    this.configureTriggerInteraction();\n  }\n  async swipeToCloseChanged(enable) {\n    if (this.gesture) {\n      this.gesture.enable(enable);\n    }\n    else if (enable) {\n      await this.initSwipeToClose();\n    }\n  }\n  breakpointsChanged(breakpoints) {\n    if (breakpoints !== undefined) {\n      this.sortedBreakpoints = breakpoints.sort((a, b) => a - b);\n    }\n  }\n  connectedCallback() {\n    const { configureTriggerInteraction, el } = this;\n    prepareOverlay(el);\n    configureTriggerInteraction();\n  }\n  disconnectedCallback() {\n    const { destroyTriggerInteraction } = this;\n    if (destroyTriggerInteraction) {\n      destroyTriggerInteraction();\n    }\n  }\n  componentWillLoad() {\n    const { breakpoints, initialBreakpoint, swipeToClose, el } = this;\n    this.inheritedAttributes = inheritAttributes(el, ['aria-label', 'role']);\n    /**\n     * If user has custom ID set then we should\n     * not assign the default incrementing ID.\n     */\n    this.modalId = this.el.hasAttribute('id') ? this.el.getAttribute('id') : `ion-modal-${this.modalIndex}`;\n    const isSheetModal = (this.isSheetModal = breakpoints !== undefined && initialBreakpoint !== undefined);\n    if (isSheetModal) {\n      this.currentBreakpoint = this.initialBreakpoint;\n    }\n    if (breakpoints !== undefined && initialBreakpoint !== undefined && !breakpoints.includes(initialBreakpoint)) {\n      printIonWarning('Your breakpoints array must include the initialBreakpoint value.');\n    }\n    if (swipeToClose) {\n      printIonWarning('swipeToClose has been deprecated in favor of canDismiss.\\n\\nIf you want a card modal to be swipeable, set canDismiss to `true`. In the next major release of Ionic, swipeToClose will be removed, and all card modals will be swipeable by default.');\n    }\n  }\n  componentDidLoad() {\n    /**\n     * If modal was rendered with isOpen=\"true\"\n     * then we should open modal immediately.\n     */\n    if (this.isOpen === true) {\n      raf(() => this.present());\n    }\n    this.breakpointsChanged(this.breakpoints);\n  }\n  /**\n   * Determines whether or not an overlay\n   * is being used inline or via a controller/JS\n   * and returns the correct delegate.\n   * By default, subsequent calls to getDelegate\n   * will use a cached version of the delegate.\n   * This is useful for calling dismiss after\n   * present so that the correct delegate is given.\n   */\n  getDelegate(force = false) {\n    if (this.workingDelegate && !force) {\n      return {\n        delegate: this.workingDelegate,\n        inline: this.inline,\n      };\n    }\n    /**\n     * If using overlay inline\n     * we potentially need to use the coreDelegate\n     * so that this works in vanilla JS apps.\n     * If a developer has presented this component\n     * via a controller, then we can assume\n     * the component is already in the\n     * correct place.\n     */\n    const parentEl = this.el.parentNode;\n    const inline = (this.inline = parentEl !== null && !this.hasController);\n    const delegate = (this.workingDelegate = inline ? this.delegate || this.coreDelegate : this.delegate);\n    return { inline, delegate };\n  }\n  /**\n   * Determines whether or not the\n   * modal is allowed to dismiss based\n   * on the state of the canDismiss prop.\n   */\n  async checkCanDismiss(data, role) {\n    const { canDismiss } = this;\n    /**\n     * TODO (FW-937) - Remove the following check in\n     * the next major release of Ionic.\n     */\n    if (canDismiss === undefined) {\n      return true;\n    }\n    if (typeof canDismiss === 'function') {\n      return canDismiss(data, role);\n    }\n    return canDismiss;\n  }\n  /**\n   * Present the modal overlay after it has been created.\n   */\n  async present() {\n    if (this.presented) {\n      return;\n    }\n    /**\n     * When using an inline modal\n     * and dismissing a modal it is possible to\n     * quickly present the modal while it is\n     * dismissing. We need to await any current\n     * transition to allow the dismiss to finish\n     * before presenting again.\n     */\n    if (this.currentTransition !== undefined) {\n      await this.currentTransition;\n    }\n    /**\n     * If the modal is presented multiple times (inline modals), we\n     * need to reset the current breakpoint to the initial breakpoint.\n     */\n    this.currentBreakpoint = this.initialBreakpoint;\n    const { inline, delegate } = this.getDelegate(true);\n    this.usersElement = await attachComponent(delegate, this.el, this.component, ['ion-page'], this.componentProps, inline);\n    await deepReady(this.usersElement);\n    writeTask(() => this.el.classList.add('show-modal'));\n    this.currentTransition = present(this, 'modalEnter', iosEnterAnimation, mdEnterAnimation, {\n      presentingEl: this.presentingElement,\n      currentBreakpoint: this.initialBreakpoint,\n      backdropBreakpoint: this.backdropBreakpoint,\n    });\n    /**\n     * TODO (FW-937) - In the next major release of Ionic, all card modals\n     * will be swipeable by default. canDismiss will be used to determine if the\n     * modal can be dismissed. This check should change to check the presence of\n     * presentingElement instead.\n     *\n     * If we did not do this check, then not using swipeToClose would mean you could\n     * not run canDismiss on swipe as there would be no swipe gesture created.\n     */\n    const hasCardModal = this.presentingElement !== undefined && (this.swipeToClose || this.canDismiss !== undefined);\n    /**\n     * We need to change the status bar at the\n     * start of the animation so that it completes\n     * by the time the card animation is done.\n     */\n    if (hasCardModal && getIonMode(this) === 'ios') {\n      // Cache the original status bar color before the modal is presented\n      this.statusBarStyle = await StatusBar.getStyle();\n      setCardStatusBarDark();\n    }\n    await this.currentTransition;\n    if (this.isSheetModal) {\n      this.initSheetGesture();\n    }\n    else if (hasCardModal) {\n      await this.initSwipeToClose();\n    }\n    /* tslint:disable-next-line */\n    if (typeof window !== 'undefined') {\n      this.keyboardOpenCallback = () => {\n        if (this.gesture) {\n          /**\n           * When the native keyboard is opened and the webview\n           * is resized, the gesture implementation will become unresponsive\n           * and enter a free-scroll mode.\n           *\n           * When the keyboard is opened, we disable the gesture for\n           * a single frame and re-enable once the contents have repositioned\n           * from the keyboard placement.\n           */\n          this.gesture.enable(false);\n          raf(() => {\n            if (this.gesture) {\n              this.gesture.enable(true);\n            }\n          });\n        }\n      };\n      window.addEventListener(KEYBOARD_DID_OPEN, this.keyboardOpenCallback);\n    }\n    this.currentTransition = undefined;\n  }\n  initSwipeToClose() {\n    var _a;\n    if (getIonMode(this) !== 'ios') {\n      return;\n    }\n    const { el } = this;\n    // All of the elements needed for the swipe gesture\n    // should be in the DOM and referenced by now, except\n    // for the presenting el\n    const animationBuilder = this.leaveAnimation || config.get('modalLeave', iosLeaveAnimation);\n    const ani = (this.animation = animationBuilder(el, { presentingEl: this.presentingElement }));\n    const contentEl = findIonContent(el);\n    if (!contentEl) {\n      printIonContentErrorMsg(el);\n      return;\n    }\n    const statusBarStyle = (_a = this.statusBarStyle) !== null && _a !== void 0 ? _a : StatusBarStyle.Default;\n    this.gesture = createSwipeToCloseGesture(el, ani, statusBarStyle, () => {\n      /**\n       * While the gesture animation is finishing\n       * it is possible for a user to tap the backdrop.\n       * This would result in the dismiss animation\n       * being played again. Typically this is avoided\n       * by setting `presented = false` on the overlay\n       * component; however, we cannot do that here as\n       * that would prevent the element from being\n       * removed from the DOM.\n       */\n      this.gestureAnimationDismissing = true;\n      this.animation.onFinish(async () => {\n        await this.dismiss(undefined, GESTURE);\n        this.gestureAnimationDismissing = false;\n      });\n    });\n    this.gesture.enable(true);\n  }\n  initSheetGesture() {\n    const { wrapperEl, initialBreakpoint, backdropBreakpoint } = this;\n    if (!wrapperEl || initialBreakpoint === undefined) {\n      return;\n    }\n    const animationBuilder = this.enterAnimation || config.get('modalEnter', iosEnterAnimation);\n    const ani = (this.animation = animationBuilder(this.el, {\n      presentingEl: this.presentingElement,\n      currentBreakpoint: initialBreakpoint,\n      backdropBreakpoint,\n    }));\n    ani.progressStart(true, 1);\n    const { gesture, moveSheetToBreakpoint } = createSheetGesture(this.el, this.backdropEl, wrapperEl, initialBreakpoint, backdropBreakpoint, ani, this.sortedBreakpoints, () => { var _a; return (_a = this.currentBreakpoint) !== null && _a !== void 0 ? _a : 0; }, () => this.sheetOnDismiss(), (breakpoint) => {\n      if (this.currentBreakpoint !== breakpoint) {\n        this.currentBreakpoint = breakpoint;\n        this.ionBreakpointDidChange.emit({ breakpoint });\n      }\n    });\n    this.gesture = gesture;\n    this.moveSheetToBreakpoint = moveSheetToBreakpoint;\n    this.gesture.enable(true);\n  }\n  sheetOnDismiss() {\n    /**\n     * While the gesture animation is finishing\n     * it is possible for a user to tap the backdrop.\n     * This would result in the dismiss animation\n     * being played again. Typically this is avoided\n     * by setting `presented = false` on the overlay\n     * component; however, we cannot do that here as\n     * that would prevent the element from being\n     * removed from the DOM.\n     */\n    this.gestureAnimationDismissing = true;\n    this.animation.onFinish(async () => {\n      this.currentBreakpoint = 0;\n      this.ionBreakpointDidChange.emit({ breakpoint: this.currentBreakpoint });\n      await this.dismiss(undefined, GESTURE);\n      this.gestureAnimationDismissing = false;\n    });\n  }\n  /**\n   * Dismiss the modal overlay after it has been presented.\n   *\n   * @param data Any data to emit in the dismiss events.\n   * @param role The role of the element that is dismissing the modal. For example, 'cancel' or 'backdrop'.\n   */\n  async dismiss(data, role) {\n    var _a;\n    if (this.gestureAnimationDismissing && role !== GESTURE) {\n      return false;\n    }\n    /**\n     * If a canDismiss handler is responsible\n     * for calling the dismiss method, we should\n     * not run the canDismiss check again.\n     */\n    if (role !== 'handler' && !(await this.checkCanDismiss(data, role))) {\n      return false;\n    }\n    /**\n     * We need to start the status bar change\n     * before the animation so that the change\n     * finishes when the dismiss animation does.\n     * TODO (FW-937)\n     */\n    const hasCardModal = this.presentingElement !== undefined && (this.swipeToClose || this.canDismiss !== undefined);\n    if (hasCardModal && getIonMode(this) === 'ios') {\n      setCardStatusBarDefault(this.statusBarStyle);\n    }\n    /* tslint:disable-next-line */\n    if (typeof window !== 'undefined' && this.keyboardOpenCallback) {\n      window.removeEventListener(KEYBOARD_DID_OPEN, this.keyboardOpenCallback);\n    }\n    /**\n     * When using an inline modal\n     * and presenting a modal it is possible to\n     * quickly dismiss the modal while it is\n     * presenting. We need to await any current\n     * transition to allow the present to finish\n     * before dismissing again.\n     */\n    if (this.currentTransition !== undefined) {\n      await this.currentTransition;\n    }\n    const enteringAnimation = activeAnimations.get(this) || [];\n    this.currentTransition = dismiss(this, data, role, 'modalLeave', iosLeaveAnimation, mdLeaveAnimation, {\n      presentingEl: this.presentingElement,\n      currentBreakpoint: (_a = this.currentBreakpoint) !== null && _a !== void 0 ? _a : this.initialBreakpoint,\n      backdropBreakpoint: this.backdropBreakpoint,\n    });\n    const dismissed = await this.currentTransition;\n    if (dismissed) {\n      const { delegate } = this.getDelegate();\n      await detachComponent(delegate, this.usersElement);\n      writeTask(() => this.el.classList.remove('show-modal'));\n      if (this.animation) {\n        this.animation.destroy();\n      }\n      if (this.gesture) {\n        this.gesture.destroy();\n      }\n      enteringAnimation.forEach((ani) => ani.destroy());\n    }\n    this.currentBreakpoint = undefined;\n    this.currentTransition = undefined;\n    this.animation = undefined;\n    return dismissed;\n  }\n  /**\n   * Returns a promise that resolves when the modal did dismiss.\n   */\n  onDidDismiss() {\n    return eventMethod(this.el, 'ionModalDidDismiss');\n  }\n  /**\n   * Returns a promise that resolves when the modal will dismiss.\n   */\n  onWillDismiss() {\n    return eventMethod(this.el, 'ionModalWillDismiss');\n  }\n  /**\n   * Move a sheet style modal to a specific breakpoint. The breakpoint value must\n   * be a value defined in your `breakpoints` array.\n   */\n  async setCurrentBreakpoint(breakpoint) {\n    if (!this.isSheetModal) {\n      printIonWarning('setCurrentBreakpoint is only supported on sheet modals.');\n      return;\n    }\n    if (!this.breakpoints.includes(breakpoint)) {\n      printIonWarning(`Attempted to set invalid breakpoint value ${breakpoint}. Please double check that the breakpoint value is part of your defined breakpoints.`);\n      return;\n    }\n    const { currentBreakpoint, moveSheetToBreakpoint, canDismiss, breakpoints } = this;\n    if (currentBreakpoint === breakpoint) {\n      return;\n    }\n    if (moveSheetToBreakpoint) {\n      this.sheetTransition = moveSheetToBreakpoint({\n        breakpoint,\n        breakpointOffset: 1 - currentBreakpoint,\n        canDismiss: canDismiss !== undefined && canDismiss !== true && breakpoints[0] === 0,\n      });\n      await this.sheetTransition;\n      this.sheetTransition = undefined;\n    }\n  }\n  /**\n   * Returns the current breakpoint of a sheet style modal\n   */\n  async getCurrentBreakpoint() {\n    return this.currentBreakpoint;\n  }\n  async moveToNextBreakpoint() {\n    const { breakpoints, currentBreakpoint } = this;\n    if (!breakpoints || currentBreakpoint == null) {\n      /**\n       * If the modal does not have breakpoints and/or the current\n       * breakpoint is not set, we can't move to the next breakpoint.\n       */\n      return false;\n    }\n    const allowedBreakpoints = breakpoints.filter((b) => b !== 0);\n    const currentBreakpointIndex = allowedBreakpoints.indexOf(currentBreakpoint);\n    const nextBreakpointIndex = (currentBreakpointIndex + 1) % allowedBreakpoints.length;\n    const nextBreakpoint = allowedBreakpoints[nextBreakpointIndex];\n    /**\n     * Sets the current breakpoint to the next available breakpoint.\n     * If the current breakpoint is the last breakpoint, we set the current\n     * breakpoint to the first non-zero breakpoint to avoid dismissing the sheet.\n     */\n    await this.setCurrentBreakpoint(nextBreakpoint);\n    return true;\n  }\n  render() {\n    const { handle, isSheetModal, presentingElement, htmlAttributes, handleBehavior, inheritedAttributes } = this;\n    const showHandle = handle !== false && isSheetModal;\n    const mode = getIonMode(this);\n    const { modalId } = this;\n    const isCardModal = presentingElement !== undefined && mode === 'ios';\n    const isHandleCycle = handleBehavior === 'cycle';\n    return (h(Host, Object.assign({ \"no-router\": true, tabindex: \"-1\" }, htmlAttributes, { style: {\n        zIndex: `${20000 + this.overlayIndex}`,\n      }, class: Object.assign({ [mode]: true, ['modal-default']: !isCardModal && !isSheetModal, [`modal-card`]: isCardModal, [`modal-sheet`]: isSheetModal, 'overlay-hidden': true }, getClassMap(this.cssClass)), id: modalId, onIonBackdropTap: this.onBackdropTap, onIonModalDidPresent: this.onLifecycle, onIonModalWillPresent: this.onLifecycle, onIonModalWillDismiss: this.onLifecycle, onIonModalDidDismiss: this.onLifecycle }), h(\"ion-backdrop\", { ref: (el) => (this.backdropEl = el), visible: this.showBackdrop, tappable: this.backdropDismiss, part: \"backdrop\" }), mode === 'ios' && h(\"div\", { class: \"modal-shadow\" }), h(\"div\", Object.assign({\n      /*\n        role and aria-modal must be used on the\n        same element. They must also be set inside the\n        shadow DOM otherwise ion-button will not be highlighted\n        when using VoiceOver: https://bugs.webkit.org/show_bug.cgi?id=247134\n      */\n      role: \"dialog\"\n    }, inheritedAttributes, { \"aria-modal\": \"true\", class: \"modal-wrapper ion-overlay-wrapper\", part: \"content\", ref: (el) => (this.wrapperEl = el) }), showHandle && (h(\"button\", { class: \"modal-handle\",\n      // Prevents the handle from receiving keyboard focus when it does not cycle\n      tabIndex: !isHandleCycle ? -1 : 0, \"aria-label\": \"Activate to adjust the size of the dialog overlaying the screen\", onClick: isHandleCycle ? this.onHandleClick : undefined, part: \"handle\" })), h(\"slot\", null))));\n  }\n  static get is() { return \"ion-modal\"; }\n  static get encapsulation() { return \"shadow\"; }\n  static get originalStyleUrls() {\n    return {\n      \"ios\": [\"modal.ios.scss\"],\n      \"md\": [\"modal.md.scss\"]\n    };\n  }\n  static get styleUrls() {\n    return {\n      \"ios\": [\"modal.ios.css\"],\n      \"md\": [\"modal.md.css\"]\n    };\n  }\n  static get properties() {\n    return {\n      \"hasController\": {\n        \"type\": \"boolean\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"boolean\",\n          \"resolved\": \"boolean\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [{\n              \"name\": \"internal\",\n              \"text\": undefined\n            }],\n          \"text\": \"\"\n        },\n        \"attribute\": \"has-controller\",\n        \"reflect\": false,\n        \"defaultValue\": \"false\"\n      },\n      \"overlayIndex\": {\n        \"type\": \"number\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"number\",\n          \"resolved\": \"number\",\n          \"references\": {}\n        },\n        \"required\": true,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [{\n              \"name\": \"internal\",\n              \"text\": undefined\n            }],\n          \"text\": \"\"\n        },\n        \"attribute\": \"overlay-index\",\n        \"reflect\": false\n      },\n      \"delegate\": {\n        \"type\": \"unknown\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"FrameworkDelegate\",\n          \"resolved\": \"FrameworkDelegate | undefined\",\n          \"references\": {\n            \"FrameworkDelegate\": {\n              \"location\": \"import\",\n              \"path\": \"../../interface\"\n            }\n          }\n        },\n        \"required\": false,\n        \"optional\": true,\n        \"docs\": {\n          \"tags\": [{\n              \"name\": \"internal\",\n              \"text\": undefined\n            }],\n          \"text\": \"\"\n        }\n      },\n      \"keyboardClose\": {\n        \"type\": \"boolean\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"boolean\",\n          \"resolved\": \"boolean\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"If `true`, the keyboard will be automatically dismissed when the overlay is presented.\"\n        },\n        \"attribute\": \"keyboard-close\",\n        \"reflect\": false,\n        \"defaultValue\": \"true\"\n      },\n      \"enterAnimation\": {\n        \"type\": \"unknown\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"AnimationBuilder\",\n          \"resolved\": \"((baseEl: any, opts?: any) => Animation) | undefined\",\n          \"references\": {\n            \"AnimationBuilder\": {\n              \"location\": \"import\",\n              \"path\": \"../../interface\"\n            }\n          }\n        },\n        \"required\": false,\n        \"optional\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Animation to use when the modal is presented.\"\n        }\n      },\n      \"leaveAnimation\": {\n        \"type\": \"unknown\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"AnimationBuilder\",\n          \"resolved\": \"((baseEl: any, opts?: any) => Animation) | undefined\",\n          \"references\": {\n            \"AnimationBuilder\": {\n              \"location\": \"import\",\n              \"path\": \"../../interface\"\n            }\n          }\n        },\n        \"required\": false,\n        \"optional\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Animation to use when the modal is dismissed.\"\n        }\n      },\n      \"breakpoints\": {\n        \"type\": \"unknown\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"number[]\",\n          \"resolved\": \"number[] | undefined\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"The breakpoints to use when creating a sheet modal. Each value in the\\narray must be a decimal between 0 and 1 where 0 indicates the modal is fully\\nclosed and 1 indicates the modal is fully open. Values are relative\\nto the height of the modal, not the height of the screen. One of the values in this\\narray must be the value of the `initialBreakpoint` property.\\nFor example: [0, .25, .5, 1]\"\n        }\n      },\n      \"initialBreakpoint\": {\n        \"type\": \"number\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"number\",\n          \"resolved\": \"number | undefined\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"A decimal value between 0 and 1 that indicates the\\ninitial point the modal will open at when creating a\\nsheet modal. This value must also be listed in the\\n`breakpoints` array.\"\n        },\n        \"attribute\": \"initial-breakpoint\",\n        \"reflect\": false\n      },\n      \"backdropBreakpoint\": {\n        \"type\": \"number\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"number\",\n          \"resolved\": \"number\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"A decimal value between 0 and 1 that indicates the\\npoint after which the backdrop will begin to fade in\\nwhen using a sheet modal. Prior to this point, the\\nbackdrop will be hidden and the content underneath\\nthe sheet can be interacted with. This value is exclusive\\nmeaning the backdrop will become active after the value\\nspecified.\"\n        },\n        \"attribute\": \"backdrop-breakpoint\",\n        \"reflect\": false,\n        \"defaultValue\": \"0\"\n      },\n      \"handle\": {\n        \"type\": \"boolean\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"boolean\",\n          \"resolved\": \"boolean | undefined\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"The horizontal line that displays at the top of a sheet modal. It is `true` by default when\\nsetting the `breakpoints` and `initialBreakpoint` properties.\"\n        },\n        \"attribute\": \"handle\",\n        \"reflect\": false\n      },\n      \"handleBehavior\": {\n        \"type\": \"string\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"ModalHandleBehavior\",\n          \"resolved\": \"\\\"cycle\\\" | \\\"none\\\" | undefined\",\n          \"references\": {\n            \"ModalHandleBehavior\": {\n              \"location\": \"import\",\n              \"path\": \"../../interface\"\n            }\n          }\n        },\n        \"required\": false,\n        \"optional\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"The interaction behavior for the sheet modal when the handle is pressed.\\n\\nDefaults to `\\\"none\\\"`, which  means the modal will not change size or position when the handle is pressed.\\nSet to `\\\"cycle\\\"` to let the modal cycle between available breakpoints when pressed.\\n\\nHandle behavior is unavailable when the `handle` property is set to `false` or\\nwhen the `breakpoints` property is not set (using a fullscreen or card modal).\"\n        },\n        \"attribute\": \"handle-behavior\",\n        \"reflect\": false,\n        \"defaultValue\": \"'none'\"\n      },\n      \"component\": {\n        \"type\": \"string\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"ComponentRef\",\n          \"resolved\": \"Function | HTMLElement | null | string | undefined\",\n          \"references\": {\n            \"ComponentRef\": {\n              \"location\": \"import\",\n              \"path\": \"../../interface\"\n            }\n          }\n        },\n        \"required\": false,\n        \"optional\": true,\n        \"docs\": {\n          \"tags\": [{\n              \"name\": \"internal\",\n              \"text\": undefined\n            }],\n          \"text\": \"The component to display inside of the modal.\"\n        },\n        \"attribute\": \"component\",\n        \"reflect\": false\n      },\n      \"componentProps\": {\n        \"type\": \"unknown\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"ComponentProps\",\n          \"resolved\": \"undefined | { [key: string]: any; }\",\n          \"references\": {\n            \"ComponentProps\": {\n              \"location\": \"import\",\n              \"path\": \"../../interface\"\n            }\n          }\n        },\n        \"required\": false,\n        \"optional\": true,\n        \"docs\": {\n          \"tags\": [{\n              \"name\": \"internal\",\n              \"text\": undefined\n            }],\n          \"text\": \"The data to pass to the modal component.\"\n        }\n      },\n      \"cssClass\": {\n        \"type\": \"string\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"string | string[]\",\n          \"resolved\": \"string | string[] | undefined\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": true,\n        \"docs\": {\n          \"tags\": [{\n              \"name\": \"internal\",\n              \"text\": undefined\n            }],\n          \"text\": \"Additional classes to apply for custom CSS. If multiple classes are\\nprovided they should be separated by spaces.\"\n        },\n        \"attribute\": \"css-class\",\n        \"reflect\": false\n      },\n      \"backdropDismiss\": {\n        \"type\": \"boolean\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"boolean\",\n          \"resolved\": \"boolean\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"If `true`, the modal will be dismissed when the backdrop is clicked.\"\n        },\n        \"attribute\": \"backdrop-dismiss\",\n        \"reflect\": false,\n        \"defaultValue\": \"true\"\n      },\n      \"showBackdrop\": {\n        \"type\": \"boolean\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"boolean\",\n          \"resolved\": \"boolean\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"If `true`, a backdrop will be displayed behind the modal.\\nThis property controls whether or not the backdrop\\ndarkens the screen when the modal is presented.\\nIt does not control whether or not the backdrop\\nis active or present in the DOM.\"\n        },\n        \"attribute\": \"show-backdrop\",\n        \"reflect\": false,\n        \"defaultValue\": \"true\"\n      },\n      \"animated\": {\n        \"type\": \"boolean\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"boolean\",\n          \"resolved\": \"boolean\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"If `true`, the modal will animate.\"\n        },\n        \"attribute\": \"animated\",\n        \"reflect\": false,\n        \"defaultValue\": \"true\"\n      },\n      \"swipeToClose\": {\n        \"type\": \"boolean\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"boolean\",\n          \"resolved\": \"boolean\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [{\n              \"name\": \"deprecated\",\n              \"text\": \"- To prevent modals from dismissing, use canDismiss instead.\"\n            }],\n          \"text\": \"If `true`, the modal can be swiped to dismiss. Only applies in iOS mode.\"\n        },\n        \"attribute\": \"swipe-to-close\",\n        \"reflect\": false,\n        \"defaultValue\": \"false\"\n      },\n      \"presentingElement\": {\n        \"type\": \"unknown\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"HTMLElement\",\n          \"resolved\": \"HTMLElement | undefined\",\n          \"references\": {\n            \"HTMLElement\": {\n              \"location\": \"global\"\n            }\n          }\n        },\n        \"required\": false,\n        \"optional\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"The element that presented the modal. This is used for card presentation effects\\nand for stacking multiple modals on top of each other. Only applies in iOS mode.\"\n        }\n      },\n      \"htmlAttributes\": {\n        \"type\": \"unknown\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"ModalAttributes\",\n          \"resolved\": \"undefined | { [key: string]: any; }\",\n          \"references\": {\n            \"ModalAttributes\": {\n              \"location\": \"import\",\n              \"path\": \"../../interface\"\n            }\n          }\n        },\n        \"required\": false,\n        \"optional\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Additional attributes to pass to the modal.\"\n        }\n      },\n      \"isOpen\": {\n        \"type\": \"boolean\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"boolean\",\n          \"resolved\": \"boolean\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"If `true`, the modal will open. If `false`, the modal will close.\\nUse this if you need finer grained control over presentation, otherwise\\njust use the modalController or the `trigger` property.\\nNote: `isOpen` will not automatically be set back to `false` when\\nthe modal dismisses. You will need to do that in your code.\"\n        },\n        \"attribute\": \"is-open\",\n        \"reflect\": false,\n        \"defaultValue\": \"false\"\n      },\n      \"trigger\": {\n        \"type\": \"string\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"string | undefined\",\n          \"resolved\": \"string | undefined\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"An ID corresponding to the trigger element that\\ncauses the modal to open when clicked.\"\n        },\n        \"attribute\": \"trigger\",\n        \"reflect\": false\n      },\n      \"keepContentsMounted\": {\n        \"type\": \"boolean\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"boolean\",\n          \"resolved\": \"boolean\",\n          \"references\": {}\n        },\n        \"required\": false,\n        \"optional\": false,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"If `true`, the component passed into `ion-modal` will\\nautomatically be mounted when the modal is created. The\\ncomponent will remain mounted even when the modal is dismissed.\\nHowever, the component will be destroyed when the modal is\\ndestroyed. This property is not reactive and should only be\\nused when initially creating a modal.\\n\\nNote: This feature only applies to inline modals in JavaScript\\nframeworks such as Angular, React, and Vue.\"\n        },\n        \"attribute\": \"keep-contents-mounted\",\n        \"reflect\": false,\n        \"defaultValue\": \"false\"\n      },\n      \"canDismiss\": {\n        \"type\": \"boolean\",\n        \"mutable\": false,\n        \"complexType\": {\n          \"original\": \"undefined | boolean | ((data?: any, role?: string) => Promise<boolean>)\",\n          \"resolved\": \"((data?: any, role?: string | undefined) => Promise<boolean>) | boolean | undefined\",\n          \"references\": {\n            \"Promise\": {\n              \"location\": \"global\"\n            }\n          }\n        },\n        \"required\": false,\n        \"optional\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Determines whether or not a modal can dismiss\\nwhen calling the `dismiss` method.\\n\\nIf the value is `true` or the value's function returns `true`, the modal will close when trying to dismiss.\\nIf the value is `false` or the value's function returns `false`, the modal will not close when trying to dismiss.\"\n        },\n        \"attribute\": \"can-dismiss\",\n        \"reflect\": false\n      }\n    };\n  }\n  static get states() {\n    return {\n      \"presented\": {}\n    };\n  }\n  static get events() {\n    return [{\n        \"method\": \"didPresent\",\n        \"name\": \"ionModalDidPresent\",\n        \"bubbles\": true,\n        \"cancelable\": true,\n        \"composed\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Emitted after the modal has presented.\"\n        },\n        \"complexType\": {\n          \"original\": \"void\",\n          \"resolved\": \"void\",\n          \"references\": {}\n        }\n      }, {\n        \"method\": \"willPresent\",\n        \"name\": \"ionModalWillPresent\",\n        \"bubbles\": true,\n        \"cancelable\": true,\n        \"composed\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Emitted before the modal has presented.\"\n        },\n        \"complexType\": {\n          \"original\": \"void\",\n          \"resolved\": \"void\",\n          \"references\": {}\n        }\n      }, {\n        \"method\": \"willDismiss\",\n        \"name\": \"ionModalWillDismiss\",\n        \"bubbles\": true,\n        \"cancelable\": true,\n        \"composed\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Emitted before the modal has dismissed.\"\n        },\n        \"complexType\": {\n          \"original\": \"OverlayEventDetail\",\n          \"resolved\": \"OverlayEventDetail<any>\",\n          \"references\": {\n            \"OverlayEventDetail\": {\n              \"location\": \"import\",\n              \"path\": \"../../interface\"\n            }\n          }\n        }\n      }, {\n        \"method\": \"didDismiss\",\n        \"name\": \"ionModalDidDismiss\",\n        \"bubbles\": true,\n        \"cancelable\": true,\n        \"composed\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Emitted after the modal has dismissed.\"\n        },\n        \"complexType\": {\n          \"original\": \"OverlayEventDetail\",\n          \"resolved\": \"OverlayEventDetail<any>\",\n          \"references\": {\n            \"OverlayEventDetail\": {\n              \"location\": \"import\",\n              \"path\": \"../../interface\"\n            }\n          }\n        }\n      }, {\n        \"method\": \"ionBreakpointDidChange\",\n        \"name\": \"ionBreakpointDidChange\",\n        \"bubbles\": true,\n        \"cancelable\": true,\n        \"composed\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Emitted after the modal breakpoint has changed.\"\n        },\n        \"complexType\": {\n          \"original\": \"ModalBreakpointChangeEventDetail\",\n          \"resolved\": \"ModalBreakpointChangeEventDetail\",\n          \"references\": {\n            \"ModalBreakpointChangeEventDetail\": {\n              \"location\": \"import\",\n              \"path\": \"../../interface\"\n            }\n          }\n        }\n      }, {\n        \"method\": \"didPresentShorthand\",\n        \"name\": \"didPresent\",\n        \"bubbles\": true,\n        \"cancelable\": true,\n        \"composed\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Emitted after the modal has presented.\\nShorthand for ionModalWillDismiss.\"\n        },\n        \"complexType\": {\n          \"original\": \"void\",\n          \"resolved\": \"void\",\n          \"references\": {}\n        }\n      }, {\n        \"method\": \"willPresentShorthand\",\n        \"name\": \"willPresent\",\n        \"bubbles\": true,\n        \"cancelable\": true,\n        \"composed\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Emitted before the modal has presented.\\nShorthand for ionModalWillPresent.\"\n        },\n        \"complexType\": {\n          \"original\": \"void\",\n          \"resolved\": \"void\",\n          \"references\": {}\n        }\n      }, {\n        \"method\": \"willDismissShorthand\",\n        \"name\": \"willDismiss\",\n        \"bubbles\": true,\n        \"cancelable\": true,\n        \"composed\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Emitted before the modal has dismissed.\\nShorthand for ionModalWillDismiss.\"\n        },\n        \"complexType\": {\n          \"original\": \"OverlayEventDetail\",\n          \"resolved\": \"OverlayEventDetail<any>\",\n          \"references\": {\n            \"OverlayEventDetail\": {\n              \"location\": \"import\",\n              \"path\": \"../../interface\"\n            }\n          }\n        }\n      }, {\n        \"method\": \"didDismissShorthand\",\n        \"name\": \"didDismiss\",\n        \"bubbles\": true,\n        \"cancelable\": true,\n        \"composed\": true,\n        \"docs\": {\n          \"tags\": [],\n          \"text\": \"Emitted after the modal has dismissed.\\nShorthand for ionModalDidDismiss.\"\n        },\n        \"complexType\": {\n          \"original\": \"OverlayEventDetail\",\n          \"resolved\": \"OverlayEventDetail<any>\",\n          \"references\": {\n            \"OverlayEventDetail\": {\n              \"location\": \"import\",\n              \"path\": \"../../interface\"\n            }\n          }\n        }\n      }];\n  }\n  static get methods() {\n    return {\n      \"present\": {\n        \"complexType\": {\n          \"signature\": \"() => Promise<void>\",\n          \"parameters\": [],\n          \"references\": {\n            \"Promise\": {\n              \"location\": \"global\"\n            },\n            \"ModalPresentOptions\": {\n              \"location\": \"global\"\n            }\n          },\n          \"return\": \"Promise<void>\"\n        },\n        \"docs\": {\n          \"text\": \"Present the modal overlay after it has been created.\",\n          \"tags\": []\n        }\n      },\n      \"dismiss\": {\n        \"complexType\": {\n          \"signature\": \"(data?: any, role?: string) => Promise<boolean>\",\n          \"parameters\": [{\n              \"tags\": [{\n                  \"name\": \"param\",\n                  \"text\": \"data Any data to emit in the dismiss events.\"\n                }],\n              \"text\": \"Any data to emit in the dismiss events.\"\n            }, {\n              \"tags\": [{\n                  \"name\": \"param\",\n                  \"text\": \"role The role of the element that is dismissing the modal. For example, 'cancel' or 'backdrop'.\"\n                }],\n              \"text\": \"The role of the element that is dismissing the modal. For example, 'cancel' or 'backdrop'.\"\n            }],\n          \"references\": {\n            \"Promise\": {\n              \"location\": \"global\"\n            },\n            \"ModalDismissOptions\": {\n              \"location\": \"global\"\n            }\n          },\n          \"return\": \"Promise<boolean>\"\n        },\n        \"docs\": {\n          \"text\": \"Dismiss the modal overlay after it has been presented.\",\n          \"tags\": [{\n              \"name\": \"param\",\n              \"text\": \"data Any data to emit in the dismiss events.\"\n            }, {\n              \"name\": \"param\",\n              \"text\": \"role The role of the element that is dismissing the modal. For example, 'cancel' or 'backdrop'.\"\n            }]\n        }\n      },\n      \"onDidDismiss\": {\n        \"complexType\": {\n          \"signature\": \"<T = any>() => Promise<OverlayEventDetail<T>>\",\n          \"parameters\": [],\n          \"references\": {\n            \"Promise\": {\n              \"location\": \"global\"\n            },\n            \"OverlayEventDetail\": {\n              \"location\": \"import\",\n              \"path\": \"../../interface\"\n            },\n            \"T\": {\n              \"location\": \"global\"\n            }\n          },\n          \"return\": \"Promise<OverlayEventDetail<T>>\"\n        },\n        \"docs\": {\n          \"text\": \"Returns a promise that resolves when the modal did dismiss.\",\n          \"tags\": []\n        }\n      },\n      \"onWillDismiss\": {\n        \"complexType\": {\n          \"signature\": \"<T = any>() => Promise<OverlayEventDetail<T>>\",\n          \"parameters\": [],\n          \"references\": {\n            \"Promise\": {\n              \"location\": \"global\"\n            },\n            \"OverlayEventDetail\": {\n              \"location\": \"import\",\n              \"path\": \"../../interface\"\n            },\n            \"T\": {\n              \"location\": \"global\"\n            }\n          },\n          \"return\": \"Promise<OverlayEventDetail<T>>\"\n        },\n        \"docs\": {\n          \"text\": \"Returns a promise that resolves when the modal will dismiss.\",\n          \"tags\": []\n        }\n      },\n      \"setCurrentBreakpoint\": {\n        \"complexType\": {\n          \"signature\": \"(breakpoint: number) => Promise<void>\",\n          \"parameters\": [{\n              \"tags\": [],\n              \"text\": \"\"\n            }],\n          \"references\": {\n            \"Promise\": {\n              \"location\": \"global\"\n            }\n          },\n          \"return\": \"Promise<void>\"\n        },\n        \"docs\": {\n          \"text\": \"Move a sheet style modal to a specific breakpoint. The breakpoint value must\\nbe a value defined in your `breakpoints` array.\",\n          \"tags\": []\n        }\n      },\n      \"getCurrentBreakpoint\": {\n        \"complexType\": {\n          \"signature\": \"() => Promise<number | undefined>\",\n          \"parameters\": [],\n          \"references\": {\n            \"Promise\": {\n              \"location\": \"global\"\n            }\n          },\n          \"return\": \"Promise<number | undefined>\"\n        },\n        \"docs\": {\n          \"text\": \"Returns the current breakpoint of a sheet style modal\",\n          \"tags\": []\n        }\n      }\n    };\n  }\n  static get elementRef() { return \"el\"; }\n  static get watchers() {\n    return [{\n        \"propName\": \"isOpen\",\n        \"methodName\": \"onIsOpenChange\"\n      }, {\n        \"propName\": \"trigger\",\n        \"methodName\": \"onTriggerChange\"\n      }, {\n        \"propName\": \"swipeToClose\",\n        \"methodName\": \"swipeToCloseChanged\"\n      }];\n  }\n}\nconst LIFECYCLE_MAP = {\n  ionModalDidPresent: 'ionViewDidEnter',\n  ionModalWillPresent: 'ionViewWillEnter',\n  ionModalWillDismiss: 'ionViewWillLeave',\n  ionModalDidDismiss: 'ionViewDidLeave',\n};\nlet modalIds = 0;\n"],"mappings":"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"}