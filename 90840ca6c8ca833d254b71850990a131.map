{"version":3,"names":["HapticEngine","getEngine","_a","win","window","TapticEngine","Capacitor","isPluginAvailable","Plugins","Haptics","available","engine","this","getPlatform","navigator","vibrate","undefined","isCordova","isCapacitor","impact","options","style","toUpperCase","notification","selection","selectionStart","gestureSelectionStart","selectionChanged","gestureSelectionChanged","selectionEnd","gestureSelectionEnd","hapticAvailable","hapticSelection","hapticSelectionStart","hapticSelectionChanged","hapticSelectionEnd","hapticImpact"],"sources":["node_modules/@ionic/core/dist/collection/utils/native/haptic.js"],"sourcesContent":["/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nconst HapticEngine = {\n  getEngine() {\n    var _a;\n    const win = window;\n    return win.TapticEngine || (((_a = win.Capacitor) === null || _a === void 0 ? void 0 : _a.isPluginAvailable('Haptics')) && win.Capacitor.Plugins.Haptics);\n  },\n  available() {\n    var _a;\n    const win = window;\n    const engine = this.getEngine();\n    if (!engine) {\n      return false;\n    }\n    /**\n     * Developers can manually import the\n     * Haptics plugin in their app which will cause\n     * getEngine to return the Haptics engine. However,\n     * the Haptics engine will throw an error if\n     * used in a web browser that does not support\n     * the Vibrate API. This check avoids that error\n     * if the browser does not support the Vibrate API.\n     */\n    if (((_a = win.Capacitor) === null || _a === void 0 ? void 0 : _a.getPlatform()) === 'web') {\n      return typeof navigator !== 'undefined' && navigator.vibrate !== undefined;\n    }\n    return true;\n  },\n  isCordova() {\n    return !!window.TapticEngine;\n  },\n  isCapacitor() {\n    const win = window;\n    return !!win.Capacitor;\n  },\n  impact(options) {\n    const engine = this.getEngine();\n    if (!engine) {\n      return;\n    }\n    const style = this.isCapacitor() ? options.style.toUpperCase() : options.style;\n    engine.impact({ style });\n  },\n  notification(options) {\n    const engine = this.getEngine();\n    if (!engine) {\n      return;\n    }\n    const style = this.isCapacitor() ? options.style.toUpperCase() : options.style;\n    engine.notification({ style });\n  },\n  selection() {\n    this.impact({ style: 'light' });\n  },\n  selectionStart() {\n    const engine = this.getEngine();\n    if (!engine) {\n      return;\n    }\n    if (this.isCapacitor()) {\n      engine.selectionStart();\n    }\n    else {\n      engine.gestureSelectionStart();\n    }\n  },\n  selectionChanged() {\n    const engine = this.getEngine();\n    if (!engine) {\n      return;\n    }\n    if (this.isCapacitor()) {\n      engine.selectionChanged();\n    }\n    else {\n      engine.gestureSelectionChanged();\n    }\n  },\n  selectionEnd() {\n    const engine = this.getEngine();\n    if (!engine) {\n      return;\n    }\n    if (this.isCapacitor()) {\n      engine.selectionEnd();\n    }\n    else {\n      engine.gestureSelectionEnd();\n    }\n  },\n};\n/**\n * Check to see if the Haptic Plugin is available\n * @return Returns `true` or false if the plugin is available\n */\nexport const hapticAvailable = () => {\n  return HapticEngine.available();\n};\n/**\n * Trigger a selection changed haptic event. Good for one-time events\n * (not for gestures)\n */\nexport const hapticSelection = () => {\n  hapticAvailable() && HapticEngine.selection();\n};\n/**\n * Tell the haptic engine that a gesture for a selection change is starting.\n */\nexport const hapticSelectionStart = () => {\n  hapticAvailable() && HapticEngine.selectionStart();\n};\n/**\n * Tell the haptic engine that a selection changed during a gesture.\n */\nexport const hapticSelectionChanged = () => {\n  hapticAvailable() && HapticEngine.selectionChanged();\n};\n/**\n * Tell the haptic engine we are done with a gesture. This needs to be\n * called lest resources are not properly recycled.\n */\nexport const hapticSelectionEnd = () => {\n  hapticAvailable() && HapticEngine.selectionEnd();\n};\n/**\n * Use this to indicate success/failure/warning to the user.\n * options should be of the type `{ type: 'success' }` (or `warning`/`error`)\n */\nexport const hapticNotification = (options) => {\n  hapticAvailable() && HapticEngine.notification(options);\n};\n/**\n * Use this to indicate success/failure/warning to the user.\n * options should be of the type `{ style: 'light' }` (or `medium`/`heavy`)\n */\nexport const hapticImpact = (options) => {\n  hapticAvailable() && HapticEngine.impact(options);\n};\n"],"mappings":";;;AAGA,IAAMA,aAAe,CACnBC,UAAS,WACP,IAAIC,EACJ,IAAMC,EAAMC,OACZ,OAAOD,EAAIE,gBAAmBH,EAAKC,EAAIG,aAAe,MAAQJ,SAAY,OAAS,EAAIA,EAAGK,kBAAkB,aAAeJ,EAAIG,UAAUE,QAAQC,OACrJ,EACEC,UAAS,WACP,IAAIR,EACJ,IAAMC,EAAMC,OACZ,IAAMO,EAASC,KAAKX,YACpB,IAAKU,EAAQ,CACX,OAAO,K,CAWT,KAAMT,EAAKC,EAAIG,aAAe,MAAQJ,SAAY,OAAS,EAAIA,EAAGW,iBAAmB,MAAO,CAC1F,cAAcC,YAAc,aAAeA,UAAUC,UAAYC,S,CAEnE,OAAO,IACX,EACEC,UAAS,WACP,QAASb,OAAOC,YACpB,EACEa,YAAW,WACT,IAAMf,EAAMC,OACZ,QAASD,EAAIG,SACjB,EACEa,OAAM,SAACC,GACL,IAAMT,EAASC,KAAKX,YACpB,IAAKU,EAAQ,CACX,M,CAEF,IAAMU,EAAQT,KAAKM,cAAgBE,EAAQC,MAAMC,cAAgBF,EAAQC,MACzEV,EAAOQ,OAAO,CAAEE,MAAKA,GACzB,EACEE,aAAY,SAACH,GACX,IAAMT,EAASC,KAAKX,YACpB,IAAKU,EAAQ,CACX,M,CAEF,IAAMU,EAAQT,KAAKM,cAAgBE,EAAQC,MAAMC,cAAgBF,EAAQC,MACzEV,EAAOY,aAAa,CAAEF,MAAKA,GAC/B,EACEG,UAAS,WACPZ,KAAKO,OAAO,CAAEE,MAAO,SACzB,EACEI,eAAc,WACZ,IAAMd,EAASC,KAAKX,YACpB,IAAKU,EAAQ,CACX,M,CAEF,GAAIC,KAAKM,cAAe,CACtBP,EAAOc,gB,KAEJ,CACHd,EAAOe,uB,CAEb,EACEC,iBAAgB,WACd,IAAMhB,EAASC,KAAKX,YACpB,IAAKU,EAAQ,CACX,M,CAEF,GAAIC,KAAKM,cAAe,CACtBP,EAAOgB,kB,KAEJ,CACHhB,EAAOiB,yB,CAEb,EACEC,aAAY,WACV,IAAMlB,EAASC,KAAKX,YACpB,IAAKU,EAAQ,CACX,M,CAEF,GAAIC,KAAKM,cAAe,CACtBP,EAAOkB,c,KAEJ,CACHlB,EAAOmB,qB,CAEb,GAMO,IAAMC,gBAAkB,WAC7B,OAAO/B,aAAaU,WACtB,EAKY,IAACsB,gBAAkB,WAC7BD,mBAAqB/B,aAAawB,WACpC,EAIY,IAACS,qBAAuB,WAClCF,mBAAqB/B,aAAayB,gBACpC,EAIY,IAACS,uBAAyB,WACpCH,mBAAqB/B,aAAa2B,kBACpC,EAKY,IAACQ,mBAAqB,WAChCJ,mBAAqB/B,aAAa6B,cACpC,EAYY,IAACO,aAAe,SAAChB,GAC3BW,mBAAqB/B,aAAamB,OAAOC,EAC3C,S"}