{"version":3,"names":["lastId","activeAnimations","WeakMap","createController","tagName","create","options","createOverlay","dismiss","data","role","id","dismissOverlay","document","getTop","getOverlay","alertController","actionSheetController","popoverController","prepareOverlay","el","connectListeners","overlayIndex","hasAttribute","concat","opts","window","customElements","whenDefined","then","element","createElement","classList","add","Object","assign","hasController","getAppRoot","appendChild","Promise","resolve","componentOnReady","focusableQueryString","focusFirstDescendant","ref","overlay","firstInput","querySelector","shadowRoot","focusElement","focus","isOverlayHidden","contains","focusLastDescendant","inputs","Array","from","querySelectorAll","lastInput","length","trapKeyboardFocus","ev","doc","lastOverlay","target","trapScopedFocus","lastFocus","undefined","overlayRoot","getElementRoot","overlayWrapper","activeElement","trapShadowFocus","addEventListener","backdropDismiss","detail","register","OVERLAY_BACK_BUTTON_PRIORITY","BACKDROP","key","overlayTag","reject","getOverlays","selector","filter","c","overlays","o","find","setRootAriaHidden","hidden","root","viewContainer","setAttribute","removeAttribute","present","name","iosEnterAnimation","mdEnterAnimation","__awaiter","presented","willPresent","emit","_a","willPresentShorthand","mode","getIonMode","animationBuilder","enterAnimation","config","get","overlayAnimation","completed","_c","sent","didPresent","_b","didPresentShorthand","focusPreviousElementOnDismiss","keyboardClose","overlayEl","previousElement","onDidDismiss","iosLeaveAnimation","mdLeaveAnimation","style","setProperty","willDismiss","willDismissShorthand","leaveAnimation","GESTURE","didDismiss","didDismissShorthand","delete","removeProperty","console","error","err_1","remove","body","baseEl","aniRoot","animation","animated","getBoolean","duration","beforeAddWrite","ownerDocument","matches","blur","activeAni","set","__spreadArray","play","eventMethod","eventName","promise","r","onceEvent","event","callback","handler","removeEventListener","isCancel","defaultGate","h","safeCall","arg","jmp","e"],"sources":["node_modules/@ionic/core/dist/collection/utils/overlays.js"],"sourcesContent":["/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { config } from '../global/config';\nimport { getIonMode } from '../global/ionic-global';\nimport { OVERLAY_BACK_BUTTON_PRIORITY } from './hardware-back-button';\nimport { addEventListener, componentOnReady, focusElement, getElementRoot, removeEventListener } from './helpers';\nlet lastId = 0;\nexport const activeAnimations = new WeakMap();\nconst createController = (tagName) => {\n  return {\n    create(options) {\n      return createOverlay(tagName, options);\n    },\n    dismiss(data, role, id) {\n      return dismissOverlay(document, data, role, tagName, id);\n    },\n    async getTop() {\n      return getOverlay(document, tagName);\n    },\n  };\n};\nexport const alertController = /*@__PURE__*/ createController('ion-alert');\nexport const actionSheetController = /*@__PURE__*/ createController('ion-action-sheet');\nexport const loadingController = /*@__PURE__*/ createController('ion-loading');\nexport const modalController = /*@__PURE__*/ createController('ion-modal');\nexport const pickerController = /*@__PURE__*/ createController('ion-picker');\nexport const popoverController = /*@__PURE__*/ createController('ion-popover');\nexport const toastController = /*@__PURE__*/ createController('ion-toast');\nexport const prepareOverlay = (el) => {\n  if (typeof document !== 'undefined') {\n    connectListeners(document);\n  }\n  const overlayIndex = lastId++;\n  el.overlayIndex = overlayIndex;\n  if (!el.hasAttribute('id')) {\n    el.id = `ion-overlay-${overlayIndex}`;\n  }\n};\nexport const createOverlay = (tagName, opts) => {\n  if (typeof window !== 'undefined' && typeof window.customElements !== 'undefined') {\n    return window.customElements.whenDefined(tagName).then(() => {\n      const element = document.createElement(tagName);\n      element.classList.add('overlay-hidden');\n      /**\n       * Convert the passed in overlay options into props\n       * that get passed down into the new overlay.\n       */\n      Object.assign(element, Object.assign(Object.assign({}, opts), { hasController: true }));\n      // append the overlay element to the document body\n      getAppRoot(document).appendChild(element);\n      return new Promise((resolve) => componentOnReady(element, resolve));\n    });\n  }\n  return Promise.resolve();\n};\n/**\n * This query string selects elements that\n * are eligible to receive focus. We select\n * interactive elements that meet the following\n * criteria:\n * 1. Element does not have a negative tabindex\n * 2. Element does not have `hidden`\n * 3. Element does not have `disabled` for non-Ionic components.\n * 4. Element does not have `disabled` or `disabled=\"true\"` for Ionic components.\n * Note: We need this distinction because `disabled=\"false\"` is\n * valid usage for the disabled property on ion-button.\n */\nconst focusableQueryString = '[tabindex]:not([tabindex^=\"-\"]):not([hidden]):not([disabled]), input:not([type=hidden]):not([tabindex^=\"-\"]):not([hidden]):not([disabled]), textarea:not([tabindex^=\"-\"]):not([hidden]):not([disabled]), button:not([tabindex^=\"-\"]):not([hidden]):not([disabled]), select:not([tabindex^=\"-\"]):not([hidden]):not([disabled]), .ion-focusable:not([tabindex^=\"-\"]):not([hidden]):not([disabled]), .ion-focusable[disabled=\"false\"]:not([tabindex^=\"-\"]):not([hidden])';\nexport const focusFirstDescendant = (ref, overlay) => {\n  let firstInput = ref.querySelector(focusableQueryString);\n  const shadowRoot = firstInput === null || firstInput === void 0 ? void 0 : firstInput.shadowRoot;\n  if (shadowRoot) {\n    // If there are no inner focusable elements, just focus the host element.\n    firstInput = shadowRoot.querySelector(focusableQueryString) || firstInput;\n  }\n  if (firstInput) {\n    focusElement(firstInput);\n  }\n  else {\n    // Focus overlay instead of letting focus escape\n    overlay.focus();\n  }\n};\nconst isOverlayHidden = (overlay) => overlay.classList.contains('overlay-hidden');\nconst focusLastDescendant = (ref, overlay) => {\n  const inputs = Array.from(ref.querySelectorAll(focusableQueryString));\n  let lastInput = inputs.length > 0 ? inputs[inputs.length - 1] : null;\n  const shadowRoot = lastInput === null || lastInput === void 0 ? void 0 : lastInput.shadowRoot;\n  if (shadowRoot) {\n    // If there are no inner focusable elements, just focus the host element.\n    lastInput = shadowRoot.querySelector(focusableQueryString) || lastInput;\n  }\n  if (lastInput) {\n    lastInput.focus();\n  }\n  else {\n    // Focus overlay instead of letting focus escape\n    overlay.focus();\n  }\n};\n/**\n * Traps keyboard focus inside of overlay components.\n * Based on https://w3c.github.io/aria-practices/examples/dialog-modal/alertdialog.html\n * This includes the following components: Action Sheet, Alert, Loading, Modal,\n * Picker, and Popover.\n * Should NOT include: Toast\n */\nconst trapKeyboardFocus = (ev, doc) => {\n  const lastOverlay = getOverlay(doc, 'ion-alert,ion-action-sheet,ion-loading,ion-modal,ion-picker,ion-popover');\n  const target = ev.target;\n  /**\n   * If no active overlay, ignore this event.\n   *\n   * If this component uses the shadow dom,\n   * this global listener is pointless\n   * since it will not catch the focus\n   * traps as they are inside the shadow root.\n   * We need to add a listener to the shadow root\n   * itself to ensure the focus trap works.\n   */\n  if (!lastOverlay || !target) {\n    return;\n  }\n  /**\n   * If the ion-disable-focus-trap class\n   * is present on an overlay, then this component\n   * instance has opted out of focus trapping.\n   * An example of this is when the sheet modal\n   * has a backdrop that is disabled. The content\n   * behind the sheet should be focusable until\n   * the backdrop is enabled.\n   */\n  if (lastOverlay.classList.contains('ion-disable-focus-trap')) {\n    return;\n  }\n  const trapScopedFocus = () => {\n    /**\n     * If we are focusing the overlay, clear\n     * the last focused element so that hitting\n     * tab activates the first focusable element\n     * in the overlay wrapper.\n     */\n    if (lastOverlay === target) {\n      lastOverlay.lastFocus = undefined;\n      /**\n       * Otherwise, we must be focusing an element\n       * inside of the overlay. The two possible options\n       * here are an input/button/etc or the ion-focus-trap\n       * element. The focus trap element is used to prevent\n       * the keyboard focus from leaving the overlay when\n       * using Tab or screen assistants.\n       */\n    }\n    else {\n      /**\n       * We do not want to focus the traps, so get the overlay\n       * wrapper element as the traps live outside of the wrapper.\n       */\n      const overlayRoot = getElementRoot(lastOverlay);\n      if (!overlayRoot.contains(target)) {\n        return;\n      }\n      const overlayWrapper = overlayRoot.querySelector('.ion-overlay-wrapper');\n      if (!overlayWrapper) {\n        return;\n      }\n      /**\n       * If the target is inside the wrapper, let the browser\n       * focus as normal and keep a log of the last focused element.\n       */\n      if (overlayWrapper.contains(target)) {\n        lastOverlay.lastFocus = target;\n      }\n      else {\n        /**\n         * Otherwise, we must have focused one of the focus traps.\n         * We need to wrap the focus to either the first element\n         * or the last element.\n         */\n        /**\n         * Once we call `focusFirstDescendant` and focus the first\n         * descendant, another focus event will fire which will\n         * cause `lastOverlay.lastFocus` to be updated before\n         * we can run the code after that. We will cache the value\n         * here to avoid that.\n         */\n        const lastFocus = lastOverlay.lastFocus;\n        // Focus the first element in the overlay wrapper\n        focusFirstDescendant(overlayWrapper, lastOverlay);\n        /**\n         * If the cached last focused element is the\n         * same as the active element, then we need\n         * to wrap focus to the last descendant. This happens\n         * when the first descendant is focused, and the user\n         * presses Shift + Tab. The previous line will focus\n         * the same descendant again (the first one), causing\n         * last focus to equal the active element.\n         */\n        if (lastFocus === doc.activeElement) {\n          focusLastDescendant(overlayWrapper, lastOverlay);\n        }\n        lastOverlay.lastFocus = doc.activeElement;\n      }\n    }\n  };\n  const trapShadowFocus = () => {\n    /**\n     * If the target is inside the wrapper, let the browser\n     * focus as normal and keep a log of the last focused element.\n     */\n    if (lastOverlay.contains(target)) {\n      lastOverlay.lastFocus = target;\n    }\n    else {\n      /**\n       * Otherwise, we are about to have focus\n       * go out of the overlay. We need to wrap\n       * the focus to either the first element\n       * or the last element.\n       */\n      /**\n       * Once we call `focusFirstDescendant` and focus the first\n       * descendant, another focus event will fire which will\n       * cause `lastOverlay.lastFocus` to be updated before\n       * we can run the code after that. We will cache the value\n       * here to avoid that.\n       */\n      const lastFocus = lastOverlay.lastFocus;\n      // Focus the first element in the overlay wrapper\n      focusFirstDescendant(lastOverlay, lastOverlay);\n      /**\n       * If the cached last focused element is the\n       * same as the active element, then we need\n       * to wrap focus to the last descendant. This happens\n       * when the first descendant is focused, and the user\n       * presses Shift + Tab. The previous line will focus\n       * the same descendant again (the first one), causing\n       * last focus to equal the active element.\n       */\n      if (lastFocus === doc.activeElement) {\n        focusLastDescendant(lastOverlay, lastOverlay);\n      }\n      lastOverlay.lastFocus = doc.activeElement;\n    }\n  };\n  if (lastOverlay.shadowRoot) {\n    trapShadowFocus();\n  }\n  else {\n    trapScopedFocus();\n  }\n};\nconst connectListeners = (doc) => {\n  if (lastId === 0) {\n    lastId = 1;\n    doc.addEventListener('focus', (ev) => {\n      trapKeyboardFocus(ev, doc);\n    }, true);\n    // handle back-button click\n    doc.addEventListener('ionBackButton', (ev) => {\n      const lastOverlay = getOverlay(doc);\n      if (lastOverlay === null || lastOverlay === void 0 ? void 0 : lastOverlay.backdropDismiss) {\n        ev.detail.register(OVERLAY_BACK_BUTTON_PRIORITY, () => {\n          return lastOverlay.dismiss(undefined, BACKDROP);\n        });\n      }\n    });\n    // handle ESC to close overlay\n    doc.addEventListener('keyup', (ev) => {\n      if (ev.key === 'Escape') {\n        const lastOverlay = getOverlay(doc);\n        if (lastOverlay === null || lastOverlay === void 0 ? void 0 : lastOverlay.backdropDismiss) {\n          lastOverlay.dismiss(undefined, BACKDROP);\n        }\n      }\n    });\n  }\n};\nexport const dismissOverlay = (doc, data, role, overlayTag, id) => {\n  const overlay = getOverlay(doc, overlayTag, id);\n  if (!overlay) {\n    return Promise.reject('overlay does not exist');\n  }\n  return overlay.dismiss(data, role);\n};\nexport const getOverlays = (doc, selector) => {\n  if (selector === undefined) {\n    selector = 'ion-alert,ion-action-sheet,ion-loading,ion-modal,ion-picker,ion-popover,ion-toast';\n  }\n  return Array.from(doc.querySelectorAll(selector)).filter((c) => c.overlayIndex > 0);\n};\n/**\n * Returns an overlay element\n * @param doc The document to find the element within.\n * @param overlayTag The selector for the overlay, defaults to Ionic overlay components.\n * @param id The unique identifier for the overlay instance.\n * @returns The overlay element or `undefined` if no overlay element is found.\n */\nexport const getOverlay = (doc, overlayTag, id) => {\n  const overlays = getOverlays(doc, overlayTag).filter((o) => !isOverlayHidden(o));\n  return id === undefined ? overlays[overlays.length - 1] : overlays.find((o) => o.id === id);\n};\n/**\n * When an overlay is presented, the main\n * focus is the overlay not the page content.\n * We need to remove the page content from the\n * accessibility tree otherwise when\n * users use \"read screen from top\" gestures with\n * TalkBack and VoiceOver, the screen reader will begin\n * to read the content underneath the overlay.\n *\n * We need a container where all page components\n * exist that is separate from where the overlays\n * are added in the DOM. For most apps, this element\n * is the top most ion-router-outlet. In the event\n * that devs are not using a router,\n * they will need to add the \"ion-view-container-root\"\n * id to the element that contains all of their views.\n *\n * TODO: If Framework supports having multiple top\n * level router outlets we would need to update this.\n * Example: One outlet for side menu and one outlet\n * for main content.\n */\nexport const setRootAriaHidden = (hidden = false) => {\n  const root = getAppRoot(document);\n  const viewContainer = root.querySelector('ion-router-outlet, ion-nav, #ion-view-container-root');\n  if (!viewContainer) {\n    return;\n  }\n  if (hidden) {\n    viewContainer.setAttribute('aria-hidden', 'true');\n  }\n  else {\n    viewContainer.removeAttribute('aria-hidden');\n  }\n};\nexport const present = async (overlay, name, iosEnterAnimation, mdEnterAnimation, opts) => {\n  var _a, _b;\n  if (overlay.presented) {\n    return;\n  }\n  setRootAriaHidden(true);\n  overlay.presented = true;\n  overlay.willPresent.emit();\n  (_a = overlay.willPresentShorthand) === null || _a === void 0 ? void 0 : _a.emit();\n  const mode = getIonMode(overlay);\n  // get the user's animation fn if one was provided\n  const animationBuilder = overlay.enterAnimation\n    ? overlay.enterAnimation\n    : config.get(name, mode === 'ios' ? iosEnterAnimation : mdEnterAnimation);\n  const completed = await overlayAnimation(overlay, animationBuilder, overlay.el, opts);\n  if (completed) {\n    overlay.didPresent.emit();\n    (_b = overlay.didPresentShorthand) === null || _b === void 0 ? void 0 : _b.emit();\n  }\n  /**\n   * When an overlay that steals focus\n   * is dismissed, focus should be returned\n   * to the element that was focused\n   * prior to the overlay opening. Toast\n   * does not steal focus and is excluded\n   * from returning focus as a result.\n   */\n  if (overlay.el.tagName !== 'ION-TOAST') {\n    focusPreviousElementOnDismiss(overlay.el);\n  }\n  /**\n   * If the focused element is already\n   * inside the overlay component then\n   * focus should not be moved from that\n   * to the overlay container.\n   */\n  if (overlay.keyboardClose && (document.activeElement === null || !overlay.el.contains(document.activeElement))) {\n    overlay.el.focus();\n  }\n};\n/**\n * When an overlay component is dismissed,\n * focus should be returned to the element\n * that presented the overlay. Otherwise\n * focus will be set on the body which\n * means that people using screen readers\n * or tabbing will need to re-navigate\n * to where they were before they\n * opened the overlay.\n */\nconst focusPreviousElementOnDismiss = async (overlayEl) => {\n  let previousElement = document.activeElement;\n  if (!previousElement) {\n    return;\n  }\n  const shadowRoot = previousElement === null || previousElement === void 0 ? void 0 : previousElement.shadowRoot;\n  if (shadowRoot) {\n    // If there are no inner focusable elements, just focus the host element.\n    previousElement = shadowRoot.querySelector(focusableQueryString) || previousElement;\n  }\n  await overlayEl.onDidDismiss();\n  previousElement.focus();\n};\nexport const dismiss = async (overlay, data, role, name, iosLeaveAnimation, mdLeaveAnimation, opts) => {\n  var _a, _b;\n  if (!overlay.presented) {\n    return false;\n  }\n  setRootAriaHidden(false);\n  overlay.presented = false;\n  try {\n    // Overlay contents should not be clickable during dismiss\n    overlay.el.style.setProperty('pointer-events', 'none');\n    overlay.willDismiss.emit({ data, role });\n    (_a = overlay.willDismissShorthand) === null || _a === void 0 ? void 0 : _a.emit({ data, role });\n    const mode = getIonMode(overlay);\n    const animationBuilder = overlay.leaveAnimation\n      ? overlay.leaveAnimation\n      : config.get(name, mode === 'ios' ? iosLeaveAnimation : mdLeaveAnimation);\n    // If dismissed via gesture, no need to play leaving animation again\n    if (role !== GESTURE) {\n      await overlayAnimation(overlay, animationBuilder, overlay.el, opts);\n    }\n    overlay.didDismiss.emit({ data, role });\n    (_b = overlay.didDismissShorthand) === null || _b === void 0 ? void 0 : _b.emit({ data, role });\n    activeAnimations.delete(overlay);\n    /**\n     * Make overlay hidden again in case it is being reused.\n     * We can safely remove pointer-events: none as\n     * overlay-hidden will set display: none.\n     */\n    overlay.el.classList.add('overlay-hidden');\n    overlay.el.style.removeProperty('pointer-events');\n  }\n  catch (err) {\n    console.error(err);\n  }\n  overlay.el.remove();\n  return true;\n};\nconst getAppRoot = (doc) => {\n  return doc.querySelector('ion-app') || doc.body;\n};\nconst overlayAnimation = async (overlay, animationBuilder, baseEl, opts) => {\n  // Make overlay visible in case it's hidden\n  baseEl.classList.remove('overlay-hidden');\n  const aniRoot = overlay.el;\n  const animation = animationBuilder(aniRoot, opts);\n  if (!overlay.animated || !config.getBoolean('animated', true)) {\n    animation.duration(0);\n  }\n  if (overlay.keyboardClose) {\n    animation.beforeAddWrite(() => {\n      const activeElement = baseEl.ownerDocument.activeElement;\n      if (activeElement === null || activeElement === void 0 ? void 0 : activeElement.matches('input,ion-input, ion-textarea')) {\n        activeElement.blur();\n      }\n    });\n  }\n  const activeAni = activeAnimations.get(overlay) || [];\n  activeAnimations.set(overlay, [...activeAni, animation]);\n  await animation.play();\n  return true;\n};\nexport const eventMethod = (element, eventName) => {\n  let resolve;\n  const promise = new Promise((r) => (resolve = r));\n  onceEvent(element, eventName, (event) => {\n    resolve(event.detail);\n  });\n  return promise;\n};\nexport const onceEvent = (element, eventName, callback) => {\n  const handler = (ev) => {\n    removeEventListener(element, eventName, handler);\n    callback(ev);\n  };\n  addEventListener(element, eventName, handler);\n};\nexport const isCancel = (role) => {\n  return role === 'cancel' || role === BACKDROP;\n};\nconst defaultGate = (h) => h();\n/**\n * Calls a developer provided method while avoiding\n * Angular Zones. Since the handler is provided by\n * the developer, we should throw any errors\n * received so that developer-provided bug\n * tracking software can log it.\n */\nexport const safeCall = (handler, arg) => {\n  if (typeof handler === 'function') {\n    const jmp = config.get('_zoneGate', defaultGate);\n    return jmp(() => {\n      try {\n        return handler(arg);\n      }\n      catch (e) {\n        throw e;\n      }\n    });\n  }\n  return undefined;\n};\nexport const BACKDROP = 'backdrop';\nexport const GESTURE = 'gesture';\n"],"mappings":"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"}